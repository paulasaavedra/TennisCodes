# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db [tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
# Ganados por jugador y año
ganados <- dbm[, .N, by = .(year, tourney_level, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[, .N, by = .(year, tourney_level, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "tourney_level", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
# Calcular porcentajes
resultados[, `% ganados` := round(Ganados * 100 / Jugados, 1)]
resultados[, `% perdidos` := round(Perdidos * 100 / Jugados, 1)]
# Crear tabla resumen de ganados
win_by_year_level <- dcast(
resultados,
year + Jugador ~ tourney_level,       # columnas por tourney_level
value.var = "Ganados",                # usamos la columna Ganados
fun.aggregate = sum,                  # sumar Ganados
fill = 0                              # llenar con 0 si no hay datos
)
# Columna de total de Ganados por jugador
win_by_year_level[, Total := rowSums(.SD), .SDcols = setdiff(colnames(win_by_year_level), c("year","Jugador"))]
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthdate= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthdate= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
# Exporta toda la tabla
write.csv(db, "/Users/paula/Documents/TennisData/TennisData/database/atp_simple.csv", row.names = TRUE)
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db [as.Date(date_match, format = "%Y-%m-%d") > as.Date("2024-12-20")]
dbm <- db [tourney_level!='CH']
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
# Paso 1: Filtrar solo las rondas de qualy
dt_qualy <- dbm[grepl("^Q[1-9]$", round_match)]
# Paso 2: Encontrar la última ronda de qualy por torneo
dt_qualy[, max_qualy_round := max(round_match), by = c('id','year')]
# Paso 3: Filtrar los partidos de la última ronda de qualy de cada torneo
dt_last_qualy <- dt_qualy[round_match == max_qualy_round]
# Paso 4: Obtener los ganadores (los que pasaron a main draw)
clasificados <- dt_last_qualy[, .(player = w_player, id, tourney_name, tourney_level, w_nac)]
clasificados_por_jugador <- clasificados [,.N,by=c('player','w_nac','tourney_level')]
View(clasificados_por_jugador)
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db [as.Date(date_match, format = "%Y-%m-%d") > as.Date("2024-12-20")]
dbm <- db [tourney_level!='CH']
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
dbm <- dbm [year == '2025']
# Paso 1: Filtrar solo las rondas de qualy
dt_qualy <- dbm[grepl("^Q[1-9]$", round_match)]
# Paso 2: Encontrar la última ronda de qualy por torneo
dt_qualy[, max_qualy_round := max(round_match), by = c('id','year')]
# Paso 3: Filtrar los partidos de la última ronda de qualy de cada torneo
dt_last_qualy <- dt_qualy[round_match == max_qualy_round]
# Paso 4: Obtener los ganadores (los que pasaron a main draw)
clasificados <- dt_last_qualy[, .(player = w_player, id, tourney_name, tourney_level, w_nac)]
clasificados_por_jugador <- clasificados [,.N,by=c('player','w_nac','tourney_level')]
View(clasificados_por_jugador)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthdate= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthdate= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
auxi <- rank [rank_position<101]
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthdate= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthdate= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
# Exporta toda la tabla
write.csv(db, "/Users/paula/Documents/TennisData/TennisData/database/atp_simple.csv", row.names = TRUE)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
auxi <- rank [rank_position<101]
auxito <- auxi [country='ARG',.N,by=c('rank_date','player')]
auxito <- auxi [country=='ARG',.N,by=c('rank_date','player')]
View(auxi)
auxito <- auxi [country=='ARG',.N,by=c('date_rank','player')]
View(auxito)
auxito <- auxi [country=='ARG',.N,by=c('date_rank')]
