streaks_arg <- streaks_arg[order(-racha_max)]
View(streaks_arg)
library(dplyr)
library(tidyr)
library(data.table)
library(kableExtra)
# === FILTRADO INICIAL ===
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>% separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
# === ORDEN DE RONDAS ===
round_order <- c("R128", "R64", "R32", "R16", "QF", "SF", "F")
dbm[, round_match := factor(round_match, levels = round_order, ordered = TRUE)]
setorder(dbm, year, date_match, tourney_name, round_match)
# === FUNCIÓN PARA CALCULAR RACHA Y OPONENTES ===
calc_streak_with_opponents <- function(results, dates, opponents) {
max_racha <- 0
racha_actual <- 0
inicio_max <- as.Date(NA)
fin_max <- as.Date(NA)
inicio_actual <- as.Date(NA)
opp_max <- character()
opp_actual <- character()
for (i in seq_along(results)) {
if (is.na(results[i])) next
if (results[i] == "W") {
if (racha_actual == 0) {
inicio_actual <- dates[i]
opp_actual <- character()
}
racha_actual <- racha_actual + 1
opp_actual <- c(opp_actual, opponents[i])
if (racha_actual > max_racha) {
max_racha <- racha_actual
inicio_max <- inicio_actual
fin_max <- dates[i]
opp_max <- opp_actual
}
} else {
racha_actual <- 0
opp_actual <- character()
}
}
return(list(
racha_max = as.numeric(max_racha),
inicio = as.Date(inicio_max),
fin = as.Date(fin_max),
oponentes = paste(opp_max, collapse = ", ")
))
}
# === DATOS SOLO PARA JUGADORES ARGENTINOS CON OPONENTES ===
long_arg <- rbind(
dbm[w_nac == "Argentina", .(player = w_player, opponent = l_player, result = "W", date_match)],
dbm[l_nac == "Argentina", .(player = l_player, opponent = w_player, result = "L", date_match)]
)
setorder(long_arg, player, date_match)
# === CALCULAR RACHA POR JUGADOR ===
streaks_arg <- long_arg[, {
r <- calc_streak_with_opponents(result, as.Date(date_match), opponent)
.(
racha_max = r$racha_max,
inicio_racha = r$inicio,
fin_racha = r$fin,
rivales_en_racha = r$oponentes
)
}, by = player]
# === ORDENAR POR RACHA MÁS LARGA ===
streaks_arg <- streaks_arg[order(-racha_max)]
View(streaks_arg)
library(dplyr)
library(tidyr)
library(kableExtra)
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status != 'Walkover']
#dbm <- dbm [surface =='Clay']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
#Filtra una fecha
#dbm <- dbm [as.Date(date_match, format = "%Y-%m-%d") > as.Date("2024-12-20")]
# Filtra enero o febrero
#dbm <- dbm[month(as.Date(date_match, format = "%Y-%m-%d")) %in% c(1, 2, 3)]
#dbm <- dbm[grepl("RIO DE J", tourney_name, ignore.case = TRUE)]
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
# --- 1) Ordenar el data.table según tu criterio ---
round_order <- c("R128", "R64", "R32", "R16", "QF", "SF", "F")
dbm[, round_match := factor(round_match, levels = round_order, ordered = TRUE)]
setorder(dbm, year, date_match, tourney_name, round_match)
# --- 2) Función para calcular la racha más larga ---
calc_streak <- function(results) {
max_racha <- 0
racha_actual <- 0
for (res in results) {
if (is.na(res)) next
if (res == "W") {
racha_actual <- racha_actual + 1
max_racha <- max(max_racha, racha_actual)
} else {
racha_actual <- 0
}
}
return(max_racha)
}
# --- 3) Generar tabla "larga" con un registro por jugador y partido ---
#    Incluye tanto cuando fue ganador como cuando fue perdedor
long <- rbind(
dbm[, .(player = w_player, opp_nac = l_nac, result = "W", date_match)],
dbm[, .(player = l_player, opp_nac = w_nac, result = "L", date_match)]
)
# --- 4) Eliminar partidos sin nacionalidad rival ---
long <- long[!is.na(opp_nac) & opp_nac != ""]
# --- 5) Ordenar por jugador, nacionalidad rival y fecha ---
setorder(long, player, opp_nac, date_match)
# --- 6) Calcular racha más larga por jugador y nacionalidad rival ---
streaks <- long[, .(racha_max = calc_streak(result)), by = .(player, opp_nac)]
View(streaks)
library(dplyr)
library(tidyr)
library(data.table)
library(kableExtra)
# --- Filtrar base ---
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
# Ajustar match_id y separar en año e id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
# Ordenar por ronda y fecha
round_order <- c("R128", "R64", "R32", "R16", "QF", "SF", "F")
dbm[, round_match := factor(round_match, levels = round_order, ordered = TRUE)]
setorder(dbm, year, date_match, tourney_name, round_match)
# --- Generar formato largo con ganador/perdedor ---
long <- rbind(
dbm[, .(player = w_player, player_nac = w_nac, opp_nac = l_nac, result = "W", date_match)],
dbm[, .(player = l_player, player_nac = l_nac, opp_nac = w_nac, result = "L", date_match)]
)
# Quitar partidos sin nacionalidad rival
long <- long[!is.na(opp_nac) & opp_nac != ""]
# Ordenar por fecha
setorder(long, date_match)
# --- Filtrar solo partidos donde el jugador es argentino ---
long_arg <- long[player_nac == "ARG"]
# --- Función para calcular racha máxima global por nacionalidad rival ---
calc_streak_global <- function(results) {
max_racha <- 0
racha_actual <- 0
for (res in results) {
if (res == "W") {
racha_actual <- racha_actual + 1
max_racha <- max(max_racha, racha_actual)
} else { # derrota corta la racha
racha_actual <- 0
}
}
return(max_racha)
}
# --- Calcular racha más larga por nacionalidad rival ---
streaks_arg <- long_arg[, .(racha_max = calc_streak_global(result)), by = opp_nac]
streaks_arg <- streaks_arg[order(-racha_max)]
library(dplyr)
library(tidyr)
library(data.table)
library(kableExtra)
# --- Filtrar base ---
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
# Ajustar match_id y separar en año e id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
# Ordenar por ronda y fecha
round_order <- c("R128", "R64", "R32", "R16", "QF", "SF", "F")
dbm[, round_match := factor(round_match, levels = round_order, ordered = TRUE)]
setorder(dbm, year, date_match, tourney_name, round_match)
# --- Generar formato largo con ganador/perdedor ---
long <- rbind(
dbm[, .(player = w_player, player_nac = w_nac, opp_nac = l_nac, result = "W", date_match)],
dbm[, .(player = l_player, player_nac = l_nac, opp_nac = w_nac, result = "L", date_match)]
)
# Quitar partidos sin nacionalidad rival
long <- long[!is.na(opp_nac) & opp_nac != ""]
# Ordenar por fecha
setorder(long, date_match)
# --- Filtrar solo partidos donde el jugador es argentino ---
long_arg <- long[player_nac == "Argentina"]
# --- Función para calcular racha máxima global por nacionalidad rival ---
calc_streak_global <- function(results) {
max_racha <- 0
racha_actual <- 0
for (res in results) {
if (res == "W") {
racha_actual <- racha_actual + 1
max_racha <- max(max_racha, racha_actual)
} else { # derrota corta la racha
racha_actual <- 0
}
}
return(max_racha)
}
# --- Calcular racha más larga por nacionalidad rival ---
streaks_arg <- long_arg[, .(racha_max = calc_streak_global(result)), by = opp_nac]
streaks_arg <- streaks_arg[order(-racha_max)]
View(streaks_arg)
library(dplyr)
library(tidyr)
library(kableExtra)
library(data.table)
# --- 0) Filtrado inicial ---
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
# Si querés filtrar fechas o torneos, podés activar alguna de estas líneas:
# dbm <- dbm[as.Date(date_match) > as.Date("2024-12-20")]
# dbm <- dbm[month(as.Date(date_match)) %in% c(1, 2, 3)]
# dbm <- dbm[grepl("RIO DE J", tourney_name, ignore.case = TRUE)]
# --- 1) Limpieza de ID de partido ---
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
# --- 2) Ordenar por ronda y fecha ---
round_order <- c("R128", "R64", "R32", "R16", "QF", "SF", "F")
dbm[, round_match := factor(round_match, levels = round_order, ordered = TRUE)]
setorder(dbm, year, date_match, tourney_name, round_match)
# --- 3) Función para calcular racha máxima ---
calc_streak <- function(results) {
max_racha <- 0
racha_actual <- 0
for (res in results) {
if (is.na(res)) next
if (res == "W") {
racha_actual <- racha_actual + 1
max_racha <- max(max_racha, racha_actual)
} else {
racha_actual <- 0
}
}
return(max_racha)
}
# --- 4) Construir tabla solo con jugadores argentinos ---
long_arg <- rbind(
dbm[w_nac == "ARG", .(player = w_player, opp_nac = l_nac, result = "W", date_match)],
dbm[l_nac == "ARG", .(player = l_player, opp_nac = w_nac, result = "L", date_match)]
)
# Eliminar rivales sin nacionalidad
long_arg <- long_arg[!is.na(opp_nac) & opp_nac != ""]
# Ordenar por jugador, nacionalidad rival y fecha
setorder(long_arg, player, opp_nac, date_match)
# --- 5) Calcular racha máxima de cada argentino contra cada país ---
streaks_arg <- long_arg[, .(racha_max = calc_streak(result)), by = .(player, opp_nac)]
# --- 6) Ordenar para ver las mejores rachas ---
streaks_arg <- streaks_arg[order(-racha_max, player)]
library(dplyr)
library(tidyr)
library(kableExtra)
library(data.table)
# --- 0) Filtrado inicial ---
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
# Si querés filtrar fechas o torneos, podés activar alguna de estas líneas:
# dbm <- dbm[as.Date(date_match) > as.Date("2024-12-20")]
# dbm <- dbm[month(as.Date(date_match)) %in% c(1, 2, 3)]
# dbm <- dbm[grepl("RIO DE J", tourney_name, ignore.case = TRUE)]
# --- 1) Limpieza de ID de partido ---
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
# --- 2) Ordenar por ronda y fecha ---
round_order <- c("R128", "R64", "R32", "R16", "QF", "SF", "F")
dbm[, round_match := factor(round_match, levels = round_order, ordered = TRUE)]
setorder(dbm, year, date_match, tourney_name, round_match)
# --- 3) Función para calcular racha máxima ---
calc_streak <- function(results) {
max_racha <- 0
racha_actual <- 0
for (res in results) {
if (is.na(res)) next
if (res == "W") {
racha_actual <- racha_actual + 1
max_racha <- max(max_racha, racha_actual)
} else {
racha_actual <- 0
}
}
return(max_racha)
}
# --- 4) Construir tabla solo con jugadores argentinos ---
long_arg <- rbind(
dbm[w_nac == "Argentina", .(player = w_player, opp_nac = l_nac, result = "W", date_match)],
dbm[l_nac == "Argentina", .(player = l_player, opp_nac = w_nac, result = "L", date_match)]
)
# Eliminar rivales sin nacionalidad
long_arg <- long_arg[!is.na(opp_nac) & opp_nac != ""]
# Ordenar por jugador, nacionalidad rival y fecha
setorder(long_arg, player, opp_nac, date_match)
# --- 5) Calcular racha máxima de cada argentino contra cada país ---
streaks_arg <- long_arg[, .(racha_max = calc_streak(result)), by = .(player, opp_nac)]
# --- 6) Ordenar para ver las mejores rachas ---
streaks_arg <- streaks_arg[order(-racha_max, player)]
# --- 7) Mostrar tabla bonita ---
streaks_arg %>%
kbl() %>%
kable_styling(full_width = FALSE)
View(streaks_arg)
streaks_arg %>%
kbl() %>%
kable_styling(full_width = FALSE,
bootstrap_options = c("striped", "hover"), # ayuda con filas alternadas
font_size = 12) %>%
row_spec(odd = 0, background = "white") %>%       # filas pares blancas (index base 1)
row_spec(even = 0, background = "#efece7") %>%    # filas impares color claro
row_spec(0, extra_css = "padding-top: 3px; padding-bottom: 3px;")  # menos padding vertical en header
streaks_arg %>%
kbl() %>%
kable_styling(
full_width = FALSE,
bootstrap_options = c("striped", "hover"),
stripe_color = "#efece7",
font_size = 12
) %>%
# Reducir padding vertical en todas las filas (incluye header)
row_spec(0, extra_css = "padding-top: 3px; padding-bottom: 3px;") %>%
row_spec(1:nrow(streaks_arg), extra_css = "padding-top: 3px; padding-bottom: 3px;")
View(streaks_arg)
View(streaks_arg)
dbm <- db
dbm <- dbm [w_nac == 'Argentina' & l_nac == 'Argentina']
dbm$player_combination <- apply(dbm[, c("w_player", "l_player")], 1, function(x) {
paste(sort(x), collapse = " vs ")
})
# Contar la frecuencia de cada combinación
combinacion_frecuencia <- table(dbm$player_combination)
combinacion_frecuencia <- data.table(combinacion = names(combinacion_frecuencia), frecuencia = combinacion_frecuencia)
View(combinacion_frecuencia)
library(dplyr)
library(tidyr)
library(kableExtra)
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status != 'Walkover']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
colnames(dbm)
dbm_same_nat <- dbm[w_nac == l_nac]
dbm_same_nat[, rivalry_pair := paste(pmin(w_player, l_player),
pmax(w_player, l_player),
sep = " vs ")]
rivalries <- dbm_same_nat[, .N, by = .(w_player, l_player, w_nac)]
setorder(rivalries, -N)
View(rivalries)
dbm_same_nat[, rivalry_pair := paste(pmin(w_player, l_player),
pmax(w_player, l_player),
sep = " vs ")]
View(dbm_same_nat)
# Filtramos partidos entre compatriotas
dbm_same_nat <- dbm[w_nac == l_nac]
# Agrupamos por ganador y perdedor y contamos victorias
counts <- dbm_same_nat[, .N, by = .(winner = w_player, loser = l_player, nac = w_nac)]
# Creamos clave única para cada rivalidad (ordenada alfabéticamente para que A vs B sea lo mismo que B vs A)
counts[, rivalry := paste(pmin(winner, loser), pmax(winner, loser), sep = " vs ")]
# Pasamos a formato ancho para tener victorias de cada uno
wide <- dcast(counts, rivalry + nac ~ winner, value.var = "N", fill = 0)
# Ahora reconstruimos de nuevo en formato "jugadorA vs jugadorB con sus victorias"
# Sacamos los nombres de los jugadores del campo rivalry
wide[, c("player1", "player2") := tstrsplit(rivalry, " vs ", fixed = TRUE)]
# Obtenemos victorias de cada uno
result <- merge(
counts[winner == player1 & loser == player2, .(rivalry, wins_A = N)],
counts[winner == player2 & loser == player1, .(rivalry, wins_B = N)],
by = "rivalry", all = TRUE
)
# Filtrar partidos entre compatriotas
dbm_same_nat <- dbm[w_nac == l_nac]
# Contar victorias de cada jugador sobre otro
counts <- dbm_same_nat[, .N, by = .(winner = w_player, loser = l_player, nac = w_nac)]
# Crear clave de rivalidad única (independiente de quién ganó)
counts[, rivalry := paste(pmin(winner, loser), pmax(winner, loser), sep = " vs ")]
# Obtener los nombres de los dos jugadores
counts[, c("player1", "player2") := tstrsplit(rivalry, " vs ", fixed = TRUE)]
# Tabla con victorias de player1 sobre player2
wins1 <- counts[winner == player1 & loser == player2, .(rivalry, nac, player1, player2, wins_A = N)]
# Tabla con victorias de player2 sobre player1
wins2 <- counts[winner == player2 & loser == player1, .(rivalry, wins_B = N)]
# Unir tablas
res <- merge(wins1, wins2, by = "rivalry", all = TRUE)
# Rellenar NA con 0
res[is.na(wins_A), wins_A := 0]
res[is.na(wins_B), wins_B := 0]
# Calcular diferencia
res[, diff := wins_A - wins_B]
# Ordenar por diferencia
setorder(res, -diff)
# Seleccionar columnas finales
res_final <- res[, .(player1, player2, nac, wins_A, wins_B, diff)]
View(res)
View(res_final)
library(dplyr)
library(data.table)
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[!round_match %in% c('Q1', 'Q2', 'Q3')]
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
tidyr::separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
# ---- Rivalidad jugador vs nacionalidad ----
# Contar victorias del jugador contra nacionalidad del rival
wins_vs_nat <- dbm[, .N, by = .(player = w_player, nat_rival = l_nac)]
# Contar derrotas del jugador contra nacionalidad del rival
losses_vs_nat <- dbm[, .N, by = .(player = l_player, nat_rival = w_nac)]
# Renombrar columnas para unir
setnames(wins_vs_nat, "N", "wins")
setnames(losses_vs_nat, "N", "losses")
# Unir tablas
res_nat <- merge(wins_vs_nat, losses_vs_nat,
by = c("player", "nat_rival"),
all = TRUE)
# Rellenar NA con 0
res_nat[is.na(wins), wins := 0]
res_nat[is.na(losses), losses := 0]
# Diferencia
res_nat[, diff := wins - losses]
# Ordenar por diferencia
setorder(res_nat, -diff)
# Resultado final
res_nat_final <- res_nat[, .(player, nat_rival, wins, losses, diff)]
View(res_nat_final)
View(res_nat)
library(dplyr)
library(data.table)
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[!round_match %in% c('Q1', 'Q2', 'Q3')]
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
tidyr::separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
# ---- Rivalidad jugador vs nacionalidad ----
# Victorias del jugador contra nacionalidad del rival
wins_vs_nat <- dbm[, .(wins = .N, player_nat = first(w_nac)),
by = .(player = w_player, nat_rival = l_nac)]
# Derrotas del jugador contra nacionalidad del rival
losses_vs_nat <- dbm[, .(losses = .N, player_nat = first(l_nac)),
by = .(player = l_player, nat_rival = w_nac)]
# Unir tablas
res_nat <- merge(wins_vs_nat, losses_vs_nat,
by = c("player", "nat_rival", "player_nat"),
all = TRUE)
# Rellenar NA con 0
res_nat[is.na(wins), wins := 0]
res_nat[is.na(losses), losses := 0]
# Calcular diferencia
res_nat[, diff := wins - losses]
# Ordenar por diferencia
setorder(res_nat, -diff)
# Resultado final con nacionalidad del jugador
res_nat_final <- res_nat[, .(player, player_nat, nat_rival, wins, losses, diff)]
View(res_nat_final)
library(dplyr)
library(tidyr)
library(stringr)
library(data.table)
dbm <- db [ match_status != 'Walkover']
dbm <- dbm [tourney_level != 'CH']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
dbm <- dbm [year=='2025' & best == 3]
dbm[, count_sets := str_count(score, "-")]
# Obtener jugadores únicos
resumen <- unique(c(dbm$w_player, dbm$l_player))
resumen <- data.table(player = resumen)
# Calcular partidos jugados (w_player + l_player)
total_partidos <- dbm[, .N, by = c("tourney_name","w_player", "l_player")]
total_partidos <- melt(total_partidos, measure.vars = c("w_player", "l_player"), value.name = "player")[, .N, by = player]
setnames(total_partidos, "N", "partidos_jugados")
# Calcular partidos jugados a 3 sets (w_player + l_player cuando count_sets == 3)
partidos_3_sets <- dbm[count_sets == 3, .N, by = c("w_player", "l_player")]
partidos_3_sets <- melt(partidos_3_sets, measure.vars = c("w_player", "l_player"), value.name = "player")[, .N, by = player]
setnames(partidos_3_sets, "N", "partidos_a_3_sets")
# Unir los datos
resumen <- merge(resumen, total_partidos, by = "player", all.x = TRUE)
resumen <- merge(resumen, partidos_3_sets, by = "player", all.x = TRUE)
# Reemplazar NA por 0 en partidos_a_3_sets
resumen[is.na(partidos_a_3_sets), partidos_a_3_sets := 0]
# Calcular la proporción de partidos a 3 sets sobre el total de partidos jugados
resumen[, prop_partidos_a_3_sets := (partidos_a_3_sets / partidos_jugados) * 100]
View(resumen)
