date_match = as.Date(date_match))]
# Unir
players_dt <- rbind(w_dt, l_dt)
# --- Paso 2. Geocodificar ---
# Necesitas clave de Google para ggmap
register_google(key = "TU_API_KEY")
# Ciudades únicas (nacimiento + países torneos)
locs <- unique(c(players_dt$birthplace, players_dt$country))
locs <- locs[!is.na(locs)]
# Obtener lat/lon
geo <- geocode(locs, output = "latlona", source = "google")
geo[, location := locs]
View(dbm)
View(dbm)
library(data.table)
library(geosphere)   # para calcular distancias geodésicas
library(ggmap)       # para geocodificar (necesita API key de Google Maps)
# Supongamos que tu tabla se llama "dbm"
setDT(dbm)
# --- Paso 1. Armar dataset "long" con todos los jugadores ---
# Ganadores
w_dt <- dbm[, .(player = w_player,
birthplace = w_birthplace,
country = country,
date_match = as.Date(date_match))]
# Perdedores
l_dt <- dbm[, .(player = l_player,
birthplace = l_birthplace,
country = country,
date_match = as.Date(date_match))]
# Unir
players_dt <- rbind(w_dt, l_dt)
# --- Paso 2. Geocodificar ---
# Necesitas clave de Google para ggmap
register_google(key = "TU_API_KEY")
# Ciudades únicas (nacimiento + países torneos)
locs <- unique(c(players_dt$birthplace, players_dt$country))
locs <- locs[!is.na(locs)]
# Obtener lat/lon
geo <- geocode(locs, output = "latlona", source = "google")
library(data.table)
library(tidygeocoder)  # para geocodificación con OpenStreetMap (gratis)
install.packages("tidygeocoder")
library(data.table)
library(tidygeocoder)  # para geocodificación con OpenStreetMap (gratis)
library(geosphere)     # para distancias geodésicas
# Supongamos que tu tabla se llama dbm
setDT(dbm)
# --- Paso 1. Formato largo ---
w_dt <- dbm[, .(player = w_player,
birthplace = w_birthplace,
location = country,
date_match = as.Date(date_match))]
l_dt <- dbm[, .(player = l_player,
birthplace = l_birthplace,
location = country,
date_match = as.Date(date_match))]
players_dt <- rbind(w_dt, l_dt)
# --- Paso 2. Geocodificar ---
# Extraer todas las ubicaciones únicas (nacimientos + torneos)
locs <- unique(c(players_dt$birthplace, players_dt$location))
locs <- locs[!is.na(locs)]
geo <- tibble::tibble(location = locs) |>
tidygeocoder::geocode(location, method = "osm", lat = lat, long = lon)
# --- Paso 3. Unir coordenadas ---
# Birthplace
players_dt <- merge(players_dt, geo,
by.x = "birthplace", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("birth_lon","birth_lat"))
# Torneo (country → ojalá sea ciudad, si no geocodifica país)
players_dt <- merge(players_dt, geo,
by.x = "location", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("tour_lon","tour_lat"))
# --- Paso 4. Ordenar trayectorias ---
setorder(players_dt, player, date_match)
# --- Paso 5. Calcular distancias ---
calc_dist <- function(x1,y1,x2,y2){
if(any(is.na(c(x1,y1,x2,y2)))) return(NA_real_)
distHaversine(c(x1,y1), c(x2,y2)) / 1000  # km
}
players_dt[, `:=`(prev_lon = shift(tour_lon, fill = birth_lon[1]),
prev_lat = shift(tour_lat, fill = birth_lat[1])),
by = player]
players_dt[, km := mapply(calc_dist, prev_lon, prev_lat, tour_lon, tour_lat)]
# --- Paso 6. Resumen ---
distances <- players_dt[, .(km_total = sum(km, na.rm = TRUE),
torneos = uniqueN(location)),
by = player]
View(distances)
dbm <- db[tourney_level=='GS' & tourney_name=='Wimbledon']
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
dbm <- dbm [year=='2025']
library(data.table)
library(tidygeocoder)  # para geocodificación con OpenStreetMap (gratis)
library(geosphere)     # para distancias geodésicas
# Supongamos que tu tabla se llama dbm
setDT(dbm)
# --- Paso 1. Formato largo ---
w_dt <- dbm[, .(player = w_player,
birthplace = w_birthplace,
location = country,
date_match = as.Date(date_match))]
l_dt <- dbm[, .(player = l_player,
birthplace = l_birthplace,
location = country,
date_match = as.Date(date_match))]
players_dt <- rbind(w_dt, l_dt)
# --- Paso 2. Geocodificar ---
# Extraer todas las ubicaciones únicas (nacimientos + torneos)
locs <- unique(c(players_dt$birthplace, players_dt$location))
locs <- locs[!is.na(locs)]
geo <- tibble::tibble(location = locs) |>
tidygeocoder::geocode(location, method = "osm", lat = lat, long = lon)
# --- Paso 3. Unir coordenadas ---
# Birthplace
players_dt <- merge(players_dt, geo,
by.x = "birthplace", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("birth_lon","birth_lat"))
# Torneo (country → ojalá sea ciudad, si no geocodifica país)
players_dt <- merge(players_dt, geo,
by.x = "location", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("tour_lon","tour_lat"))
# --- Paso 4. Ordenar trayectorias ---
setorder(players_dt, player, date_match)
# --- Paso 5. Calcular distancias ---
calc_dist <- function(x1,y1,x2,y2){
if(any(is.na(c(x1,y1,x2,y2)))) return(NA_real_)
distHaversine(c(x1,y1), c(x2,y2)) / 1000  # km
}
players_dt[, `:=`(prev_lon = shift(tour_lon, fill = birth_lon[1]),
prev_lat = shift(tour_lat, fill = birth_lat[1])),
by = player]
players_dt[, km := mapply(calc_dist, prev_lon, prev_lat, tour_lon, tour_lat)]
# --- Paso 6. Resumen ---
distances <- players_dt[, .(km_total = sum(km, na.rm = TRUE),
torneos = uniqueN(location)),
by = player]
View(distances)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
library(dplyr)
library(tidyr)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthplace= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthplace],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthplace= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthplace],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthplace", "l_birthplace")
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_rank", "w_birthplace", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_rank", "l_birthplace", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
dbm <- db
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
dbm <- dbm [year=='2025']
library(data.table)
library(tidygeocoder)  # para geocodificación con OpenStreetMap (gratis)
library(geosphere)     # para distancias geodésicas
# Supongamos que tu tabla se llama dbm
setDT(dbm)
# --- Paso 1. Formato largo ---
w_dt <- dbm[, .(player = w_player,
birthplace = w_birthplace,
location = country,
date_match = as.Date(date_match))]
l_dt <- dbm[, .(player = l_player,
birthplace = l_birthplace,
location = country,
date_match = as.Date(date_match))]
players_dt <- rbind(w_dt, l_dt)
# --- Paso 2. Geocodificar ---
# Extraer todas las ubicaciones únicas (nacimientos + torneos)
locs <- unique(c(players_dt$birthplace, players_dt$location))
locs <- locs[!is.na(locs)]
geo <- tibble::tibble(location = locs) |>
tidygeocoder::geocode(location, method = "osm", lat = lat, long = lon)
# --- Paso 3. Unir coordenadas ---
# Birthplace
players_dt <- merge(players_dt, geo,
by.x = "birthplace", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("birth_lon","birth_lat"))
# Torneo (country → ojalá sea ciudad, si no geocodifica país)
players_dt <- merge(players_dt, geo,
by.x = "location", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("tour_lon","tour_lat"))
# --- Paso 4. Ordenar trayectorias ---
setorder(players_dt, player, date_match)
# --- Paso 5. Calcular distancias ---
calc_dist <- function(x1,y1,x2,y2){
if(any(is.na(c(x1,y1,x2,y2)))) return(NA_real_)
distHaversine(c(x1,y1), c(x2,y2)) / 1000  # km
}
players_dt[, `:=`(prev_lon = shift(tour_lon, fill = birth_lon[1]),
prev_lat = shift(tour_lat, fill = birth_lat[1])),
by = player]
players_dt[, km := mapply(calc_dist, prev_lon, prev_lat, tour_lon, tour_lat)]
# --- Paso 6. Resumen ---
distances <- players_dt[, .(km_total = sum(km, na.rm = TRUE),
torneos = uniqueN(location)),
by = player]
View(distances)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
library(dplyr)
library(tidyr)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthplace= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthplace],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthplace= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthplace],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthplace", "l_birthplace")
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_rank", "w_birthplace", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_rank", "l_birthplace", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
dbm <- db [tourney_level != 'CH']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
dbm <- dbm [year=='2025']
library(data.table)
library(tidygeocoder)  # para geocodificación con OpenStreetMap (gratis)
library(geosphere)     # para distancias geodésicas
# Supongamos que tu tabla se llama dbm
setDT(dbm)
# --- Paso 1. Formato largo ---
w_dt <- dbm[, .(player = w_player,
birthplace = w_birthplace,
location = country,
date_match = as.Date(date_match))]
l_dt <- dbm[, .(player = l_player,
birthplace = l_birthplace,
location = country,
date_match = as.Date(date_match))]
players_dt <- rbind(w_dt, l_dt)
# --- Paso 2. Geocodificar ---
# Extraer todas las ubicaciones únicas (nacimientos + torneos)
locs <- unique(c(players_dt$birthplace, players_dt$location))
locs <- locs[!is.na(locs)]
geo <- tibble::tibble(location = locs) |>
tidygeocoder::geocode(location, method = "osm", lat = lat, long = lon)
# --- Paso 3. Unir coordenadas ---
# Birthplace
players_dt <- merge(players_dt, geo,
by.x = "birthplace", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("birth_lon","birth_lat"))
# Torneo (country → ojalá sea ciudad, si no geocodifica país)
players_dt <- merge(players_dt, geo,
by.x = "location", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("tour_lon","tour_lat"))
# --- Paso 4. Ordenar trayectorias ---
setorder(players_dt, player, date_match)
# --- Paso 5. Calcular distancias ---
calc_dist <- function(x1,y1,x2,y2){
if(any(is.na(c(x1,y1,x2,y2)))) return(NA_real_)
distHaversine(c(x1,y1), c(x2,y2)) / 1000  # km
}
players_dt[, `:=`(prev_lon = shift(tour_lon, fill = birth_lon[1]),
prev_lat = shift(tour_lat, fill = birth_lat[1])),
by = player]
players_dt[, km := mapply(calc_dist, prev_lon, prev_lat, tour_lon, tour_lat)]
# --- Paso 6. Resumen ---
distances <- players_dt[, .(km_total = sum(km, na.rm = TRUE),
torneos = uniqueN(location)),
by = player]
View(distances)
dbm <- db
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
dbm <- dbm [year=='2025']
library(data.table)
library(tidygeocoder)  # para geocodificación con OpenStreetMap (gratis)
library(geosphere)     # para distancias geodésicas
# Supongamos que tu tabla se llama dbm
setDT(dbm)
# --- Paso 1. Formato largo ---
w_dt <- dbm[, .(player = w_player,
birthplace = w_birthplace,
location = country,
date_match = as.Date(date_match))]
l_dt <- dbm[, .(player = l_player,
birthplace = l_birthplace,
location = country,
date_match = as.Date(date_match))]
players_dt <- rbind(w_dt, l_dt)
# --- Paso 2. Geocodificar ---
# Extraer todas las ubicaciones únicas (nacimientos + torneos)
locs <- unique(c(players_dt$birthplace, players_dt$location))
locs <- locs[!is.na(locs)]
geo <- tibble::tibble(location = locs) |>
tidygeocoder::geocode(location, method = "osm", lat = lat, long = lon)
# --- Paso 3. Unir coordenadas ---
# Birthplace
players_dt <- merge(players_dt, geo,
by.x = "birthplace", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("birth_lon","birth_lat"))
# Torneo (country → ojalá sea ciudad, si no geocodifica país)
players_dt <- merge(players_dt, geo,
by.x = "location", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("tour_lon","tour_lat"))
# --- Paso 4. Ordenar trayectorias ---
setorder(players_dt, player, date_match)
# --- Paso 5. Calcular distancias ---
calc_dist <- function(x1,y1,x2,y2){
if(any(is.na(c(x1,y1,x2,y2)))) return(NA_real_)
distHaversine(c(x1,y1), c(x2,y2)) / 1000  # km
}
players_dt[, `:=`(prev_lon = shift(tour_lon, fill = birth_lon[1]),
prev_lat = shift(tour_lat, fill = birth_lat[1])),
by = player]
players_dt[, km := mapply(calc_dist, prev_lon, prev_lat, tour_lon, tour_lat)]
# --- Paso 6. Resumen ---
distances <- players_dt[, .(km_total = sum(km, na.rm = TRUE),
torneos = uniqueN(location)),
by = player]
View(distances)
