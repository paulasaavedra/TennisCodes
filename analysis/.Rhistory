dbm[, year := as.integer(year)]
# Ganados por jugador y año
ganados <- dbm[, .N, by = .(year, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[, .N, by = .(year, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
View(resultados)
View(db)
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db[tourney_level != 'CH' & tourney_level != 'DC']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[!round_match %in% c('Q1', 'Q2', 'Q3')]
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
# Ganados por jugador y año
ganados <- dbm[w_nac=='Argentina', .N, by = .(year, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[l_nac=='Argentina', .N, by = .(year, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
# Calcular porcentajes
resultados[, `% ganados` := round(Ganados * 100 / Jugados, 1)]
resultados[, `% perdidos` := round(Perdidos * 100 / Jugados, 1)]
View(resultados)
# Para cada año, quedate con los 3 jugadores con más triunfos
top3_por_año <- resultados[
order(-Ganados),
head(.SD, 5),
by = year
]
View(top3_por_año)
View(resultados)
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db[tourney_level != 'CH' ]
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[!round_match %in% c('Q1', 'Q2', 'Q3')]
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
# Ganados por jugador y año
ganados <- dbm[w_nac=='Argentina', .N, by = .(year, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[l_nac=='Argentina', .N, by = .(year, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
# Calcular porcentajes
resultados[, `% ganados` := round(Ganados * 100 / Jugados, 1)]
resultados[, `% perdidos` := round(Perdidos * 100 / Jugados, 1)]
View(resultados)
# Para cada año, quedate con los 3 jugadores con más triunfos
top3_por_año <- resultados[
order(-Ganados),
head(.SD, 1),
by = year
]
View(top3_por_año)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
#setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
#setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthdate= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthdate= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db[tourney_level == 'DC']
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
# Ganados por jugador y año
ganados <- dbm[, .N, by = .(year, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[, .N, by = .(year, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
# Calcular porcentajes
resultados[, `% ganados` := round(Ganados * 100 / Jugados, 1)]
resultados[, `% perdidos` := round(Perdidos * 100 / Jugados, 1)]
# Para cada año, quedate con los 3 jugadores con más triunfos
top3_por_año <- resultados[
order(-Ganados),
head(.SD, 2),
by = year
]
# Solo jugadores con al menos 10 victorias en el año
top3_efectividad <- resultados[Ganados >= 10][
order(-`% ganados`),
head(.SD, 3),
by = year
]
View(top3_por_año)
View(resultados)
View(dbm)
View(db)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
#setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
#setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthdate= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthdate= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db[tourney_level == 'DC']
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
#setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
#setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthdate= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthdate= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db[tourney_level == 'DC']
dbm <- dbm[match_status != 'Walkover']
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
# Ganados por jugador y año
ganados <- dbm[, .N, by = .(year, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[, .N, by = .(year, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
# Calcular porcentajes
resultados[, `% ganados` := round(Ganados * 100 / Jugados, 1)]
resultados[, `% perdidos` := round(Perdidos * 100 / Jugados, 1)]
View(resultados)
