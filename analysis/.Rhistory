setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(dplyr)
library(tidyr)
library(stringr)
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status != 'Walkover']
#dbm <- dbm [surface =='Clay']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
# Merge con stats
dbm <- merge(dbm, db_stats_l_t, by = "match_id", all.x = TRUE)
dbm <- merge(dbm, db_stats_w_t, by = "match_id", all.x = TRUE)
# elijo cuantos sets voy a cosiderar, en este caso 3
dbm <- dbm %>%
mutate(cantidad_de_sets = str_count(score, "-"))
# Calculo el rate entre puntos jugados y errores no forzados
dbm$w_rate <- dbm$w_t_total_points_played / dbm$w_t_unforced_errors
dbm$l_rate <- dbm$l_t_total_points_played / dbm$l_t_unforced_errors
# calculo winners - ENF
dbm$w_win_enf <- dbm$w_t_winners - dbm$w_t_unforced_errors
dbm$l_win_enf <- dbm$l_t_winners - dbm$l_t_unforced_errors
# jugadores que ganaron/ perdieron partidos de 3 sets con 65 ENF
# Crear el data.table de ganadores
ganadores <- dbm[cantidad_de_sets == 3 & w_t_unforced_errors > 64,
.(tourney_level, round_match, date_match,
player = w_player,
total_points_played = w_t_total_points_played,
unforced_errors = w_t_unforced_errors,
winners = w_t_winners,
rate = w_rate,
win_enf = w_win_enf)]
# Crear el data.table de perdedores
perdedores <- dbm[cantidad_de_sets == 3 & l_t_unforced_errors > 64,
.(tourney_level, round_match, date_match,
player = l_player,
total_points_played = l_t_total_points_played,
unforced_errors = l_t_unforced_errors,
winners = l_t_winners,
rate = l_rate,
win_enf = l_win_enf)]
# Unir los dos data.tables
jugadores <- rbind(ganadores, perdedores)
View(jugadores)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthdate= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthdate= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
library(dplyr)
library(tidyr)
library(kableExtra)
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status != 'Walkover']
#dbm <- dbm [surface =='Clay']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
#Filtra una fecha
#dbm <- dbm [as.Date(date_match, format = "%Y-%m-%d") > as.Date("2024-12-20")]
# Filtra enero o febrero
#dbm <- dbm[month(as.Date(date_match, format = "%Y-%m-%d")) %in% c(1, 2, 3)]
#dbm <- dbm[grepl("RIO DE J", tourney_name, ignore.case = TRUE)]
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
library(dplyr)
library(tidyr)
library(kableExtra)
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status != 'Walkover']
#dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
dbm <- dbm [round_match in ('Q1','Q2','Q3')
dbm <- dbm[dbm$round_match %in% c('Q1', 'Q2', 'Q3'), ]
# Ganados por jugador y año
ganados <- dbm[, .N, by = .(year, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[, .N, by = .(year, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
# Calcular porcentajes
resultados[, `% ganados` := round(Ganados * 100 / Jugados, 1)]
resultados[, `% perdidos` := round(Perdidos * 100 / Jugados, 1)]
View(resultados)
dbm <- dbm[dbm$round_match %in% c('Q1', 'Q2', 'Q3'), ]
dbm <- dbm [tourney_level=='M1000']
# Ganados por jugador y año
ganados <- dbm[, .N, by = .(year, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[, .N, by = .(year, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
# Calcular porcentajes
resultados[, `% ganados` := round(Ganados * 100 / Jugados, 1)]
resultados[, `% perdidos` := round(Perdidos * 100 / Jugados, 1)]
View(resultados)
View(db)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthdate= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthdate= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
library(dplyr)
library(tidyr)
library(kableExtra)
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status != 'Finished']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
tourney_uncompleted <- db[,.N,by=c('year','id','tourney_name','surface')]
View(dbm)
tourney_uncompleted <- dbm[,.N,by=c('year','id','tourney_name','surface')]
View(tourney_uncompleted)
tourney_uncompleted <- dbm[,.N,by=c('year','id','tourney_name','surface','tourney:level')]
tourney_uncompleted <- dbm[,.N,by=c('year','id','tourney_name','surface','tourney_level')]
View(db)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthdate= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthdate= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
# Creamos columnas auxiliares para identificar el par de jugadores sin importar el orden
dbm[, player1 := pmin(w_player, l_player)]
dbm[, player2 := pmax(w_player, l_player)]
# Contar partidos por torneo (id + year) y par de jugadores
matches_repeated <- dbm[, .N, by = .(year, id, tourney_name, tourney_level, player1, player2)]
# Filtrar los pares que jugaron más de una vez en ese mismo torneo y año
matches_repeated <- matches_repeated[N > 1]
View(matches_repeated)
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
# Creamos columnas auxiliares para identificar el par de jugadores sin importar el orden
dbm[, player1 := pmin(w_player, l_player)]
dbm[, player2 := pmax(w_player, l_player)]
# Contar partidos por torneo (id + year) y par de jugadores
matches_repeated <- dbm[, .N, by = .(year, player1, player2)]
# Filtrar los pares que jugaron más de una vez en ese mismo torneo y año
matches_repeated <- matches_repeated[N > 1]
View(matches_repeated)
