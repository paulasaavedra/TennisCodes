players_dt <- merge(players_dt, geo,
by.x = "location", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("tour_lon","tour_lat"))
# --- Paso 4. Ordenar trayectorias ---
setorder(players_dt, player, date_match)
# --- Paso 5. Calcular distancias ---
calc_dist <- function(x1,y1,x2,y2){
if(any(is.na(c(x1,y1,x2,y2)))) return(NA_real_)
distHaversine(c(x1,y1), c(x2,y2)) / 1000  # km
}
players_dt[, `:=`(prev_lon = shift(tour_lon, fill = birth_lon[1]),
prev_lat = shift(tour_lat, fill = birth_lat[1])),
by = player]
players_dt[, km := mapply(calc_dist, prev_lon, prev_lat, tour_lon, tour_lat)]
# --- Paso 6. Resumen ---
distances <- players_dt[, .(km_total = sum(km, na.rm = TRUE),
torneos = uniqueN(location)),
by = player]
View(distances)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
library(dplyr)
library(tidyr)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthplace= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthplace],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthplace= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthplace],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthplace", "l_birthplace")
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_rank", "w_birthplace", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_rank", "l_birthplace", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
dbm <- db [tourney_level != 'CH']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
dbm <- dbm [year=='2025']
library(data.table)
library(tidygeocoder)  # para geocodificación con OpenStreetMap (gratis)
library(geosphere)     # para distancias geodésicas
# Supongamos que tu tabla se llama dbm
setDT(dbm)
# --- Paso 1. Formato largo ---
w_dt <- dbm[, .(player = w_player,
birthplace = w_birthplace,
location = country,
date_match = as.Date(date_match))]
l_dt <- dbm[, .(player = l_player,
birthplace = l_birthplace,
location = country,
date_match = as.Date(date_match))]
players_dt <- rbind(w_dt, l_dt)
# --- Paso 2. Geocodificar ---
# Extraer todas las ubicaciones únicas (nacimientos + torneos)
locs <- unique(c(players_dt$birthplace, players_dt$location))
locs <- locs[!is.na(locs)]
geo <- tibble::tibble(location = locs) |>
tidygeocoder::geocode(location, method = "osm", lat = lat, long = lon)
# --- Paso 3. Unir coordenadas ---
# Birthplace
players_dt <- merge(players_dt, geo,
by.x = "birthplace", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("birth_lon","birth_lat"))
# Torneo (country → ojalá sea ciudad, si no geocodifica país)
players_dt <- merge(players_dt, geo,
by.x = "location", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("tour_lon","tour_lat"))
# --- Paso 4. Ordenar trayectorias ---
setorder(players_dt, player, date_match)
# --- Paso 5. Calcular distancias ---
calc_dist <- function(x1,y1,x2,y2){
if(any(is.na(c(x1,y1,x2,y2)))) return(NA_real_)
distHaversine(c(x1,y1), c(x2,y2)) / 1000  # km
}
players_dt[, `:=`(prev_lon = shift(tour_lon, fill = birth_lon[1]),
prev_lat = shift(tour_lat, fill = birth_lat[1])),
by = player]
players_dt[, km := mapply(calc_dist, prev_lon, prev_lat, tour_lon, tour_lat)]
# --- Paso 6. Resumen ---
distances <- players_dt[, .(km_total = sum(km, na.rm = TRUE),
torneos = uniqueN(location)),
by = player]
View(distances)
dbm <- db
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
dbm <- dbm [year=='2025']
library(data.table)
library(tidygeocoder)  # para geocodificación con OpenStreetMap (gratis)
library(geosphere)     # para distancias geodésicas
# Supongamos que tu tabla se llama dbm
setDT(dbm)
# --- Paso 1. Formato largo ---
w_dt <- dbm[, .(player = w_player,
birthplace = w_birthplace,
location = country,
date_match = as.Date(date_match))]
l_dt <- dbm[, .(player = l_player,
birthplace = l_birthplace,
location = country,
date_match = as.Date(date_match))]
players_dt <- rbind(w_dt, l_dt)
# --- Paso 2. Geocodificar ---
# Extraer todas las ubicaciones únicas (nacimientos + torneos)
locs <- unique(c(players_dt$birthplace, players_dt$location))
locs <- locs[!is.na(locs)]
geo <- tibble::tibble(location = locs) |>
tidygeocoder::geocode(location, method = "osm", lat = lat, long = lon)
# --- Paso 3. Unir coordenadas ---
# Birthplace
players_dt <- merge(players_dt, geo,
by.x = "birthplace", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("birth_lon","birth_lat"))
# Torneo (country → ojalá sea ciudad, si no geocodifica país)
players_dt <- merge(players_dt, geo,
by.x = "location", by.y = "location", all.x = TRUE)
setnames(players_dt, c("lon","lat"), c("tour_lon","tour_lat"))
# --- Paso 4. Ordenar trayectorias ---
setorder(players_dt, player, date_match)
# --- Paso 5. Calcular distancias ---
calc_dist <- function(x1,y1,x2,y2){
if(any(is.na(c(x1,y1,x2,y2)))) return(NA_real_)
distHaversine(c(x1,y1), c(x2,y2)) / 1000  # km
}
players_dt[, `:=`(prev_lon = shift(tour_lon, fill = birth_lon[1]),
prev_lat = shift(tour_lat, fill = birth_lat[1])),
by = player]
players_dt[, km := mapply(calc_dist, prev_lon, prev_lat, tour_lon, tour_lat)]
# --- Paso 6. Resumen ---
distances <- players_dt[, .(km_total = sum(km, na.rm = TRUE),
torneos = uniqueN(location)),
by = player]
View(distances)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthdate= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthdate= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
library(dplyr)
library(tidyr)
library(kableExtra)
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status != 'Walkover']
#dbm <- dbm [surface =='Clay']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
#Filtra una fecha
#dbm <- dbm [as.Date(date_match, format = "%Y-%m-%d") > as.Date("2024-12-20")]
# Filtra enero o febrero
#dbm <- dbm[month(as.Date(date_match, format = "%Y-%m-%d")) %in% c(1, 2, 3)]
#dbm <- dbm[grepl("RIO DE J", tourney_name, ignore.case = TRUE)]
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
dbm <- dbm [year=='2025']
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
# Para saber edad y paises en que ingresaron al top 100
library(data.table)
dbm <- rank [rank_position < 171]
dbm <- dbm[, .SD[c(1)], by=player]
library(dplyr)
library(lubridate)
# 1. Tomamos la tabla dbm (primer ingreso al top200)
# Suponiendo que dbm ya tiene solo la primera vez que cada jugador fue top200
# 2. De rank sacamos la primera posición de cada jugador en el año del debut
rank_inicio <- rank %>%
mutate(year = year(date_rank)) %>%
group_by(player, year) %>%
filter(date_rank == min(date_rank)) %>%
summarise(first_rank_pos = rank_position, .groups = "drop")
# 3. Ahora unimos con dbm
debut200 <- dbm %>%
mutate(year = year(date_rank)) %>%
left_join(rank_inicio, by = c("player", "year")) %>%
select(
player,
country,
debut_date = date_rank,
debut_rank = rank_position,
first_rank_year = first_rank_pos,
age
)
debut200$posiciones <- debut200$first_rank_year - debut200$debut_rank
View(debut200)
565-170
colnames (rank)
View(rank)
library(data.table)
# Si no está en Date todavía, convertirlo
rank[, date_rank := as.Date(date_rank)]
# Filtrar solo 2025
rank2025 <- rank[format(date_rank, "%Y") == "2025"]
# Resumir por jugador
res <- rank2025[
,
.(
age       = first(age),  # asumiendo que no cambia
first_pos = rank_position[which.min(date_rank)],
last_pos  = rank_position[which.max(date_rank)]
),
by = player
]
# Calcular diferencia (negativo = mejoró, positivo = empeoró)
res[, diff_pos := last_pos - first_pos]
View(res)
library(data.table)
# Asegurar formato Date
rank[, date_rank := as.Date(date_rank)]
# Identificar jugadores que ANTES de 2025 estuvieron en posición 200 o peor
jugadores_fuera <- rank[
date_rank < as.Date("2025-01-01") & rank_position >= 200,
unique(player)
]
# Filtrar los que queremos mantener
rank_filtrado <- rank[!player %in% jugadores_fuera]
# Ahora trabajar solo con 2025
rank2025 <- rank_filtrado[format(date_rank, "%Y") == "2025"]
# Resumir por jugador
res <- rank2025[
,
.(
age       = first(age),
first_pos = rank_position[which.min(date_rank)],
last_pos  = rank_position[which.max(date_rank)]
),
by = player
]
# Calcular diferencia (positivo = empeoró, negativo = mejoró)
res[, diff_pos := last_pos - first_pos]
View(res)
library(data.table)
# Si no está en Date todavía, convertirlo
rank[, date_rank := as.Date(date_rank)]
# Filtrar solo 2025
rank2025 <- rank[format(date_rank, "%Y") == "2025"]
# Resumir por jugador
res <- rank2025[
,
.(
age       = first(age),  # asumiendo que no cambia
first_pos = rank_position[which.min(date_rank)],
last_pos  = rank_position[which.max(date_rank)]
),
by = player
]
# Calcular diferencia (negativo = mejoró, positivo = empeoró)
res[, diff_pos := last_pos - first_pos]
library(data.table)
# Si no está en Date todavía, convertirlo
rank[, date_rank := as.Date(date_rank)]
# Filtrar solo 2025
rank2025 <- rank[format(date_rank, "%Y") == "2025"]
# Resumir por jugador
res <- rank2025[
,
.(
age       = first(age),  # asumiendo que no cambia
first_pos = rank_position[which.min(date_rank)],
last_pos  = rank_position[which.max(date_rank)]
),
by = player
]
# Calcular diferencia (negativo = mejoró, positivo = empeoró)
res[, diff_pos := firt_pos - last_pos]
library(data.table)
# Si no está en Date todavía, convertirlo
rank[, date_rank := as.Date(date_rank)]
# Filtrar solo 2025
rank2025 <- rank[format(date_rank, "%Y") == "2025"]
# Resumir por jugador
res <- rank2025[
,
.(
age       = first(age),  # asumiendo que no cambia
first_pos = rank_position[which.min(date_rank)],
last_pos  = rank_position[which.max(date_rank)]
),
by = player
]
# Calcular diferencia (negativo = mejoró, positivo = empeoró)
res[, diff_pos := first_pos - last_pos]
View(res)
