prom_aces = mean(w_t_ace_per_match, na.rm = TRUE),
prom_df = mean(w_t_df_per_match, na.rm = TRUE),
prom_svpct = mean(w_t_svpt_svr_per_match, na.rm = TRUE),
prom_bpsv_pct = mean(w_t_bp_save_percentage, na.rm = TRUE),
prom_games_saque = mean(w_t_service_games, na.rm = TRUE)
)]
colnames(db)
colnames(cerundolo_matches)
colnames(ceru)
library(data.table)
library(lubridate)
# Hacemos el merge con stats
db <- merge(db, db_stats_l_t, by = "match_id", all.x = TRUE)
db <- merge(db, db_stats_w_t, by = "match_id", all.x = TRUE)
# Asegurarse de que la tabla esté en formato data.table
setDT(db)
# Convertir columna de fechas si es necesario
db[, date_match := as.Date(date_match)]
# Fecha de corte
fecha_inicio <- as.Date("2025-01-01")
fecha_hoy <- Sys.Date()
player_stat = 'Juan Manuel Cerundolo'
# Filtrar partidos donde jugó Juan Manuel Cerúndolo y la fecha está dentro del rango
cerundolo_matches <- db[
(w_player == player_stat | l_player == player_stat) &
date_match >= fecha_inicio & date_match <= fecha_hoy
]
ganados <- cerundolo_matches[w_player == player_stat]
perdidos <- cerundolo_matches[l_player == player_stat]
cerundolo_matches[, jugador := fifelse(w_player == player_stat, "w", "l")]
# Puntos ganados con 1er saque
cerundolo_matches[, pg_1er_saque := fifelse(jugador == "w", w_t_1st_serve_points_won, l_t_1st_serve_points_won)]
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
library(lubridate)
# Hacemos el merge con stats
db <- merge(db, db_stats_l_t, by = "match_id", all.x = TRUE)
db <- merge(db, db_stats_w_t, by = "match_id", all.x = TRUE)
# Asegurarse de que la tabla esté en formato data.table
setDT(db)
# Convertir columna de fechas si es necesario
db[, date_match := as.Date(date_match)]
# Fecha de corte
fecha_inicio <- as.Date("2025-01-01")
fecha_hoy <- Sys.Date()
player_stat = 'Juan Manuel Cerundolo'
# Filtrar partidos donde jugó Juan Manuel Cerúndolo y la fecha está dentro del rango
cerundolo_matches <- db[
(w_player == player_stat | l_player == player_stat) &
date_match >= fecha_inicio & date_match <= fecha_hoy
]
ganados <- cerundolo_matches[w_player == player_stat]
perdidos <- cerundolo_matches[l_player == player_stat]
cerundolo_matches[, jugador := fifelse(w_player == player_stat, "w", "l")]
# Puntos ganados con 1er saque
cerundolo_matches[, pg_1er_saque := fifelse(jugador == "w", w_t_1st_serve_points_won, l_t_1st_serve_points_won)]
cerundolo_matches[, tot_1er_saque := fifelse(jugador == "w", w_t_1st_serve_points_played, l_t_1st_serve_points_played)]
# Puntos ganados con 2do saque
cerundolo_matches[, pg_2do_saque := fifelse(jugador == "w", w_t_2nd_serve_points_won, l_t_2nd_serve_points_won)]
cerundolo_matches[, tot_2do_saque := fifelse(jugador == "w", w_t_2nd_serve_points_played, l_t_2nd_serve_points_played)]
# Puntos ganados con el servicio (1ro + 2do)
cerundolo_matches[, pg_servicio := fifelse(jugador == "w", w_t_service_points_won, l_t_service_points_won)]
cerundolo_matches[, tot_servicio := fifelse(jugador == "w", w_t_service_points_played, l_t_service_points_played)]
# Puntos ganados con devolución de 1ro
cerundolo_matches[, pg_primera_dev := fifelse(jugador == "w", w_t_1st_return_points_won, l_t_1st_return_points_won)]
cerundolo_matches[, tot_primera_dev := fifelse(jugador == "w", w_t_1st_return_points_played, l_t_1st_return_points_played)]
# Puntos ganados con devolución de 2do
cerundolo_matches[, pg_segunda_dev := fifelse(jugador == "w", w_t_2nd_return_points_won, l_t_2nd_return_points_won)]
cerundolo_matches[, tot_segunda_dev := fifelse(jugador == "w", w_t_2nd_return_points_played, l_t_2nd_return_points_played)]
# Puntos ganados en devolución total
cerundolo_matches[, pg_devolucion := fifelse(jugador == "w", w_t_return_points_won, l_t_return_points_won)]
cerundolo_matches[, tot_devolucion := fifelse(jugador == "w", w_t_return_points_played, l_t_return_points_played)]
cerundolo_matches[, rate_pg_primer_saque := pg_1er_saque / (tot_1er_saque)]
cerundolo_matches[, rate_pg_segundo_saque := pg_2do_saque / (tot_2do_saque)]
cerundolo_matches[, rate_pg_servicio := pg_servicio / (tot_servicio)]
cerundolo_matches[, rate_pg_primera_dev := pg_primera_dev / (tot_primera_dev)]
cerundolo_matches[, rate_pg_segunda_dev := pg_segunda_dev / (tot_segunda_dev)]
cerundolo_matches[, rate_pg_devolucion := pg_devolucion / (tot_devolucion)]
# Crear columna de mes en formato año-mes
cerundolo_matches[, mes := format(date_match, "%Y-%m")]
# Crear la nueva columna concatenando el mes y el nombre del torneo
cerundolo_matches[, date_tourney := paste(format(date_match, "%m"), tourney_name, sep = "_")]
cerundolo_matches <- cerundolo_matches[order(date_match)]
orden_torneos <- unique(cerundolo_matches$tourney_name)
# -------------------------------
# 1. Asegurar que es data.table
# -------------------------------
ceru <- as.data.table(cerundolo_matches)
# -------------------------------
# 2. Promedios generales del saque
# -------------------------------
library(data.table)
# --------------------------------------------------------------------
# 1. Resumen general del saque
# --------------------------------------------------------------------
saque_resumen <- ceru[, .(
prom_rate_1er = mean(rate_pg_primer_saque, na.rm = TRUE),
prom_rate_2do = mean(rate_pg_segundo_saque, na.rm = TRUE),
prom_pct_1er = mean(w_t_1st_serve_percentage, na.rm = TRUE),
prom_pct_2do = mean(w_t_2nd_serve_points_won_percentage, na.rm = TRUE),
prom_aces = mean(w_t_aces, na.rm = TRUE),
prom_df = mean(w_t_double_faults, na.rm = TRUE),
prom_svpct = mean(w_t_service_points_won_percentage, na.rm = TRUE),
prom_bpsv_pct = mean(w_t_break_points_saved_percentage, na.rm = TRUE),
prom_games_saque = mean(w_t_service_games_won_percentage, na.rm = TRUE)
)]
print(saque_resumen)
# --------------------------------------------------------------------
# 2. Análisis del primer saque
# --------------------------------------------------------------------
primer_saque <- ceru[, .(
pct_1er_saque = mean(w_t_1st_serve_percentage, na.rm = TRUE),
puntos_ganados = mean(rate_pg_primer_saque, na.rm = TRUE)
)]
print(primer_saque)
# --------------------------------------------------------------------
# 3. Análisis del segundo saque
# --------------------------------------------------------------------
segundo_saque <- ceru[, .(
pct_2do_saque = mean(w_t_2nd_serve_points_won_percentage, na.rm = TRUE),
puntos_ganados = mean(rate_pg_segundo_saque, na.rm = TRUE)
)]
print(segundo_saque)
# --------------------------------------------------------------------
# 4. Aces y dobles faltas
# --------------------------------------------------------------------
aces_df <- ceru[, .(
aces_por_partido = mean(w_t_aces, na.rm = TRUE),
df_por_partido   = mean(w_t_double_faults, na.rm = TRUE),
ratio_aces_df    = mean(w_t_aces - w_t_double_faults, na.rm = TRUE)
)]
print(aces_df)
# --------------------------------------------------------------------
# 5. Games ganados al saque
# --------------------------------------------------------------------
games_saque <- ceru[, .(
games_saque_ganados = mean(w_t_service_games_won_percentage, na.rm = TRUE),
puntos_sa_saque = mean(w_t_service_points_won_percentage, na.rm = TRUE)
)]
print(games_saque)
# --------------------------------------------------------------------
# 6. Break points salvados
# --------------------------------------------------------------------
bps <- ceru[, .(
bp_salvados_pct = mean(w_t_break_points_saved_percentage, na.rm = TRUE)
)]
print(bps)
# --------------------------------------------------------------------
# 7. Comparación contra rivales
# --------------------------------------------------------------------
comparacion_rivales <- ceru[, .(
diff_1er_saque_pct = mean(w_t_1st_serve_percentage - l_t_1st_serve_percentage, na.rm = TRUE),
diff_2do_saque_pct = mean(
w_t_2nd_serve_points_won_percentage - l_t_2nd_serve_points_won_percentage,
na.rm = TRUE
),
diff_pts_1er       = mean(rate_pg_primer_saque - rate_lg_primer_saque, na.rm = TRUE),
diff_pts_2do       = mean(rate_pg_segundo_saque - rate_lg_segundo_saque, na.rm = TRUE)
)]
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
#setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
#setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
library(lubridate)
# ======================================
# Función principal
# ======================================
proyeccion_ranking <- function(rank_db, player_name, tournament_date, tournament_name, point_table) {
# ---- Normalizo tipos de datos ----
rank_db[, date := as.Date(date)]
tournament_date <- as.Date(tournament_date)
# ---- 1. Puntos actuales del jugador ----
# Se usa el ranking más reciente ANTES del torneo
current_points <- rank_db[player == player_name & date < tournament_date][
order(-date)][1, points]
if (is.na(current_points)) stop("No hay ranking reciente para ese jugador.")
# ---- 2. Puntos que defiende (año anterior) ----
last_year_date <- tournament_date - 365
defended_points <- rank_db[
player == player_name &
abs(as.numeric(date - last_year_date)) <= 7 &  # ventana +/- 7 días
grepl(tournament_name, tournament, ignore.case = TRUE),
sum(points_change, na.rm = TRUE)
]
if (is.na(defended_points)) defended_points <- 0
# ---- 3. Proyección por ronda ----
# point_table debe tener columna "round" y "points_win"
projections <- point_table[, {
new_points <- current_points - defended_points + points_win
# Ranking proyectado = posición que tendría con ese total
# Busco ranking real de esa semana (la del torneo)
ranking_week <- rank_db[date == max(rank_db[date <= tournament_date]$date),
.(player, points)]
ranking_week[, projected_rank := frank(-points, ties.method = "min")]
new_rank <- ranking_week[points <= new_points, min(projected_rank, na.rm = TRUE)]
if (is.infinite(new_rank)) new_rank <- max(ranking_week$projected_rank)
list(
round = round,
sum_points = points_win,
defended_points = defended_points,
new_total = new_points,
new_rank = new_rank
)
}]
return(list(
jugador = player_name,
torneo = tournament_name,
fecha = tournament_date,
puntos_actuales = current_points,
puntos_defiende = defended_points,
proyecciones = projections
))
}
# ======================================
# Tabla de puntos de ejemplo
# Cambiala según Slam / M1000 / 500 / 250
# ======================================
point_table_atp250 <- data.table(
round = c("R1", "R2", "QF", "SF", "F", "W"),
points_win = c(0, 25, 50, 100, 165, 250)
)
resultado <- proyeccion_ranking(
rank_db = rank_db,
player_name = "Francisco Cerúndolo",
tournament_date = "2025-04-10",
tournament_name = "Marrakech",
point_table = point_table_atp250
)
library(data.table)
library(lubridate)
rank_db <- rank
# ======================================
# Función principal
# ======================================
proyeccion_ranking <- function(rank_db, player_name, tournament_date, tournament_name, point_table) {
# ---- Normalizo tipos de datos ----
rank_db[, date := as.Date(date)]
tournament_date <- as.Date(tournament_date)
# ---- 1. Puntos actuales del jugador ----
# Se usa el ranking más reciente ANTES del torneo
current_points <- rank_db[player == player_name & date < tournament_date][
order(-date)][1, points]
if (is.na(current_points)) stop("No hay ranking reciente para ese jugador.")
# ---- 2. Puntos que defiende (año anterior) ----
last_year_date <- tournament_date - 365
defended_points <- rank_db[
player == player_name &
abs(as.numeric(date - last_year_date)) <= 7 &  # ventana +/- 7 días
grepl(tournament_name, tournament, ignore.case = TRUE),
sum(points_change, na.rm = TRUE)
]
if (is.na(defended_points)) defended_points <- 0
# ---- 3. Proyección por ronda ----
# point_table debe tener columna "round" y "points_win"
projections <- point_table[, {
new_points <- current_points - defended_points + points_win
# Ranking proyectado = posición que tendría con ese total
# Busco ranking real de esa semana (la del torneo)
ranking_week <- rank_db[date == max(rank_db[date <= tournament_date]$date),
.(player, points)]
ranking_week[, projected_rank := frank(-points, ties.method = "min")]
new_rank <- ranking_week[points <= new_points, min(projected_rank, na.rm = TRUE)]
if (is.infinite(new_rank)) new_rank <- max(ranking_week$projected_rank)
list(
round = round,
sum_points = points_win,
defended_points = defended_points,
new_total = new_points,
new_rank = new_rank
)
}]
return(list(
jugador = player_name,
torneo = tournament_name,
fecha = tournament_date,
puntos_actuales = current_points,
puntos_defiende = defended_points,
proyecciones = projections
))
}
# ======================================
# Tabla de puntos de ejemplo
# Cambiala según Slam / M1000 / 500 / 250
# ======================================
point_table_atp250 <- data.table(
round = c("R1", "R2", "QF", "SF", "F", "W"),
points_win = c(0, 25, 50, 100, 165, 250)
)
resultado <- proyeccion_ranking(
rank_db = rank_db,
player_name = "Francisco Cerúndolo",
tournament_date = "2025-04-10",
tournament_name = "Marrakech",
point_table = point_table_atp250
)
View(rank_db)
library(data.table)
library(lubridate)
rank_db <- rank
# ======================================
# Función principal
# ======================================
proyeccion_ranking <- function(rank_db, player_name, tournament_date, tournament_name, point_table) {
# ---- Normalizo tipos de datos ----
rank_db[, date := as.Date(date_rank)]
tournament_date <- as.Date(tournament_date)
# ---- 1. Puntos actuales del jugador ----
# Se usa el ranking más reciente ANTES del torneo
current_points <- rank_db[player == player_name & date < tournament_date][
order(-date)][1, points]
if (is.na(current_points)) stop("No hay ranking reciente para ese jugador.")
# ---- 2. Puntos que defiende (año anterior) ----
last_year_date <- tournament_date - 365
defended_points <- rank_db[
player == player_name &
abs(as.numeric(date - last_year_date)) <= 7 &  # ventana +/- 7 días
grepl(tournament_name, tournament, ignore.case = TRUE),
sum(points_change, na.rm = TRUE)
]
if (is.na(defended_points)) defended_points <- 0
# ---- 3. Proyección por ronda ----
# point_table debe tener columna "round" y "points_win"
projections <- point_table[, {
new_points <- current_points - defended_points + points_win
# Ranking proyectado = posición que tendría con ese total
# Busco ranking real de esa semana (la del torneo)
ranking_week <- rank_db[date == max(rank_db[date <= tournament_date]$date),
.(player, points)]
ranking_week[, projected_rank := frank(-points, ties.method = "min")]
new_rank <- ranking_week[points <= new_points, min(projected_rank, na.rm = TRUE)]
if (is.infinite(new_rank)) new_rank <- max(ranking_week$projected_rank)
list(
round = round,
sum_points = points_win,
defended_points = defended_points,
new_total = new_points,
new_rank = new_rank
)
}]
return(list(
jugador = player_name,
torneo = tournament_name,
fecha = tournament_date,
puntos_actuales = current_points,
puntos_defiende = defended_points,
proyecciones = projections
))
}
# ======================================
# Tabla de puntos de ejemplo
# Cambiala según Slam / M1000 / 500 / 250
# ======================================
point_table_atp250 <- data.table(
round = c("R1", "R2", "QF", "SF", "F", "W"),
points_win = c(0, 25, 50, 100, 165, 250)
)
resultado <- proyeccion_ranking(
rank_db = rank_db,
player_name = "Francisco Cerúndolo",
tournament_date = "2025-04-10",
tournament_name = "Marrakech",
point_table = point_table_atp250
)
library(data.table)
library(lubridate)
rank_db <- rank
# ======================================
# Función principal
# ======================================
proyeccion_ranking <- function(rank_db, player_name, tournament_date, tournament_name, point_table) {
# ---- Normalizo tipos de datos ----
rank_db[, date := as.Date(date_rank)]
tournament_date <- as.Date(tournament_date)
# ---- 1. Puntos actuales del jugador ----
# Se usa el ranking más reciente ANTES del torneo
current_points <- rank_db[player == player_name & date < tournament_date][
order(-date)][1, points]
if (is.na(current_points)) stop("No hay ranking reciente para ese jugador.")
# ---- 2. Puntos que defiende (año anterior) ----
last_year_date <- tournament_date - 365
defended_points <- rank_db[
player == player_name &
abs(as.numeric(date - last_year_date)) <= 7 &  # ventana +/- 7 días
grepl(tournament_name, tournament, ignore.case = TRUE),
sum(points_change, na.rm = TRUE)
]
if (is.na(defended_points)) defended_points <- 0
# ---- 3. Proyección por ronda ----
# point_table debe tener columna "round" y "points_win"
projections <- point_table[, {
new_points <- current_points - defended_points + points_win
# Ranking proyectado = posición que tendría con ese total
# Busco ranking real de esa semana (la del torneo)
ranking_week <- rank_db[date == max(rank_db[date <= tournament_date]$date),
.(player, points)]
ranking_week[, projected_rank := frank(-points, ties.method = "min")]
new_rank <- ranking_week[points <= new_points, min(projected_rank, na.rm = TRUE)]
if (is.infinite(new_rank)) new_rank <- max(ranking_week$projected_rank)
list(
round = round,
sum_points = points_win,
defended_points = defended_points,
new_total = new_points,
new_rank = new_rank
)
}]
return(list(
jugador = player_name,
torneo = tournament_name,
fecha = tournament_date,
puntos_actuales = current_points,
puntos_defiende = defended_points,
proyecciones = projections
))
}
# ======================================
# Tabla de puntos de ejemplo
# Cambiala según Slam / M1000 / 500 / 250
# ======================================
point_table_atp250 <- data.table(
round = c("R1", "R2", "QF", "SF", "F", "W"),
points_win = c(0, 25, 50, 100, 165, 250)
)
resultado <- proyeccion_ranking(
rank_db = rank_db,
player_name = "Francisco Cerundolo",
tournament_date = "2025-04-10",
tournament_name = "Marrakech",
point_table = point_table_atp250
)
library(dplyr)
# Trabajo con el ranking
rank[, date_rank := as.Date(date_rank, format="%d/%m/%Y")]
arg_rank <- rank [country == 'ARG']
colnames(arg_rank)
library(dplyr)
library(data.table)
# Trabajo con el ranking
rank[, date_rank := as.Date(date_rank, format="%d/%m/%Y")]
arg_rank <- rank [country == 'ARG']
# Suponiendo que arg_rank es un data.table
# 1. Obtener la última semana del año
ultima_semana <- arg_rank[, max(date)]
# 2. Filtrar esa semana y ordenar por puntos
top3_argentinos <- arg_rank[date == ultima_semana][
order(-points)
][1:3, .(player, points)]
View(top3_argentinos)
library(dplyr)
library(data.table)
# Trabajo con el ranking
rank[, date_rank := as.Date(date_rank, format="%d/%m/%Y")]
arg_rank <- rank [country == 'ARG']
# Asegurar que la columna date sea Date
arg_rank[, date := as.Date(date)]
# Crear columna año
arg_rank[, year := year(date)]
# 1. Obtener la última fecha (semana) disponible de cada año
ultima_semana_por_anio <- arg_rank[, .(last_date = max(date)), by = year]
# 2. Unir y filtrar esas fechas
arg_ultimo_dia <- arg_rank[ultima_semana_por_anio, on = .(year, date = last_date)]
# 3. Para cada año, ordenar por puntos y tomar top 3
top3_por_anio <- arg_ultimo_dia[order(year, -points),
.SD[1:3],
by = year,
.SDcols = c("player", "points")]
View(top3_por_anio)
auxi <- top3_por_anio[,.N,by=player]
View(auxi)
auxi <- top3_por_anio[points>2000]
auxi <- auxi[,.N,by=player]
View(auxi)
