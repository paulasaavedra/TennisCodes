tabla_heatmap_semanal <- tickets_semanal %>%
count(dia_semana, hora, name = "cantidad")
ggplot(tabla_heatmap_semanal, aes(x = hora, y = fct_rev(dia_semana), fill = cantidad)) +
geom_tile(color = "white", size = 0.25) +
scale_fill_gradient(low = "#e6f5ff", high = "#004c99") +
labs(
title = "Distribución de Tickets por Día y Hora",
subtitle = "Volumen de actividad durante la semana",
x = "Hora del Día",
y = "Día de la Semana",
fill = "Nº de Tickets"
) +
theme_minimal() +
theme(
plot.title = element_text(face = "bold", size = 16, hjust = 0.5),
plot.subtitle = element_text(size = 12, hjust = 0.5),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10),
legend.position = "bottom"
) +
scale_x_continuous(breaks = seq(0, 23, by = 2))
#============== Umbrales para el Grafo =======================
# Se puede ajustar estos valores según
UMBRAL_HORAS <- 10 # Se toman los tickets que fueron resulto en más de 10 horas
UMBRAL_COMENTARIOS <- 10 # Indica el mínimo de comentarios totales que tiene el ticket
tickets_unicos <- tickets_unicos %>%
mutate(
tiempo_resolucion_horas = as.numeric(
difftime(`Ticket Tiempo terminado`, `Hora de creación (Ticket)`, units = "hours")
)
) %>%
filter(!is.na(tiempo_resolucion_horas)) %>%
filter(`Módulo` != "--Ninguna--") %>%
filter(
# Elimina las filas que son: "Fuera de Horario" o "Sábado"
!(`Módulo` == "Fuera de Horario de Atención" | `Módulo` == "Sábado")
)
df_metricas_unicas <- tickets_unicos %>%
filter(`Número de comentarios` > UMBRAL_COMENTARIOS) %>%
filter(tiempo_resolucion_horas > UMBRAL_HORAS) %>%
mutate(
Ticket_ID = as.character(`ID de Ticket`)
) %>%
select(Ticket_ID, Asunto, Clasificaciones, Módulo, `Número de comentarios`,
tiempo_resolucion_horas, `Cerrado por (Ticket)`)
# Lista de IDs de tickets que pasaron el filtro
ids_criticos <- df_metricas_unicas$Ticket_ID
df_transacciones <- tickets_reducidos %>%
filter(`ID de Ticket` %in% ids_criticos) %>%
mutate(
Ticket_ID = as.character(`ID de Ticket`)
) %>%
# Filtra NA o vacío
filter(!is.na(`Comentado por`) & `Comentado por` != "") %>%
# Columnas necesarias para las aristas
select(Ticket_ID, `Comentado por`)
# Une la información de métricas a las transacciones
# Esto asegura que cada interacción tiene los datos de tiempo y comentarios del ticket.
df_interacciones_final <- df_transacciones %>%
inner_join(df_metricas_unicas, by = "Ticket_ID")
#========= Aristas ===================================
df_aristas <- df_interacciones_final %>%
# Contar la frecuencia de la interacción (Peso de la arista)
rename(from = Ticket_ID, to = `Comentado por`) %>%
group_by(from, to) %>%
summarise(Peso = n(), .groups = 'drop')
#========= Nodos ===================================
# Usamos df_metricas_unicas porque es la lista limpia de los tickets
df_nodos_tickets <- df_metricas_unicas %>%
mutate(
Ticket_Referencia = str_extract(Asunto, "#\\d+"),
Ticket_Referencia = str_replace(Ticket_Referencia, "#", "")
) %>%
select(
id = Ticket_ID,
Tipo = Módulo,
Tiempo_Horas = tiempo_resolucion_horas,
Num_Comentarios = `Número de comentarios`,
Ticket_Referencia,
Cerrado_Por = `Cerrado por (Ticket)`
) %>%
mutate(group = "Ticket")
#========= Combinación de Aristas con Nodos ===================================
# IDs únicos limpios
empleados_unicos <- df_aristas %>% pull(to) %>% unique()
empleados_cierre_unicos <- df_metricas_unicas %>% pull(`Cerrado por (Ticket)`) %>% unique()
all_empleados_id <- unique(c(empleados_unicos, empleados_cierre_unicos))
# Dataframe de empleados y cálculo de métricas
df_nodos_empleados <- data.frame(id = all_empleados_id) %>%
mutate(
group = "Empleado",
Rol_Cierre = sapply(id, function(empleado_id) {
sum(df_metricas_unicas$`Cerrado por (Ticket)` == empleado_id, na.rm = TRUE)
}),
Total_Interacciones = sapply(id, function(empleado_id) {
sum(df_aristas$Peso[df_aristas$to == empleado_id], na.rm = TRUE)
})
) %>%
filter(id != "" & !is.na(id) & id != "null")
# Combina todos los nodos
df_nodos_final <- bind_rows(df_nodos_tickets %>% mutate(id = as.character(id)),
df_nodos_empleados %>% mutate(id = as.character(id))) %>%
filter(!is.na(id))
#========= Visualización ===================================
df_nodos_vis <- df_nodos_final %>%
mutate(
value = case_when(
group == "Ticket" ~ pmax(5, sqrt(Tiempo_Horas)),
group == "Empleado" ~ pmax(5, sqrt(Total_Interacciones))
),
# Obtener el Asunto del df_metricas_unicas para el Tooltip
asunto_ticket = df_metricas_unicas$Asunto[match(id, df_metricas_unicas$Ticket_ID)],
title = case_when(
group == "Ticket" ~ paste0("Ticket ID: ", id,
"<br>Asunto: ", asunto_ticket,
"<br>Horas Activo: ", round(Tiempo_Horas, 1),
"<br>Comentarios Total: ", Num_Comentarios,
"<br>Cerrado Por: ", Cerrado_Por),
group == "Empleado" ~ paste0("Empleado: ", id,
"<br>Tickets Cerrados: ", Rol_Cierre,
"<br>Comentarios Realizados: ", Total_Interacciones)
),
color = case_when(
# --- REGLAS ---
group == "Ticket" & Tiempo_Horas ~ "#F08080",    # tiempo
group == "Empleado" & Rol_Cierre == 0 & Total_Interacciones > 5 ~ "#FFD700", # Involucrado pero no decisivo
group == "Empleado" & Rol_Cierre < 2 & Total_Interacciones < 5 ~ "lightgray",  # Bajo impacto/Actividad
# --- REGLAS GENERALES (Colores Normales y Claros) ---
group == "Empleado" & Rol_Cierre > 0 ~ "forestgreen",  # Rol de resolución final
TRUE ~ "lightgray" # Valor por defecto para cualquier otro caso
),
label = id
)
df_aristas_vis <- df_aristas %>%
mutate(
width = pmax(1, log1p(Peso)),
title = paste("Comentarios:", Peso),
color = "grey"
)
# --- Gráfico
g <- graph_from_data_frame(d = df_aristas_vis, vertices = df_nodos_vis, directed = FALSE)
grafico_final <- visIgraph(g) %>%
visOptions(
highlightNearest = TRUE,
nodesIdSelection = FALSE,
selectedBy = NULL
) %>%
visEdges(arrows = "from") %>%
visLayout(randomSeed = 123) %>%
visPhysics(enabled = FALSE)
print(grafico_final)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthdate= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthdate= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
View(db)
dbm <- db[l_rank<4 & (score == "6-0 6-1" | score == "6-1 6-0")]
View(dbm)
dbm <- db[ (score == "6-0 6-1" | score == "6-1 6-0")]
dbm <- db[l_rank<4 & (score == "6-0 6-1" | score == "6-1 6-0")]
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
#setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
#setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(data.table)
# Define la ruta del archivo CSV
ruta_csv <- "/Users/paula/Documents/TennisData/TennisData/players_ATP/ATP_DatabaseTML.csv"
# Leer el CSV en un data.table
players_database <- fread(ruta_csv)
# 1. Pasar a minúsculas
players_database[, id := tolower(id)]
# 3. Seleccionar solo las columnas necesarias de players_database
players_subset <- players_database[, .(id, birthdate, weight, height, turnedpro, birthplace, hand, backhand)]
# 4. Merge con repetición automática de valores para jugadores duplicados
rank <- merge(rank,
players_subset,
by.x = "player_id",
by.y = "id",
all.x = TRUE,
sort = FALSE,
allow.cartesian = TRUE)
# 1) Copia de base de partidos
db_complete <- copy(db)
# 2) Preparar ranking con fechas en formato Date
rank[, date_rank := as.Date(date_rank, format = "%d/%m/%Y")]
rank[, player_lower := tolower(player)]
setkey(rank, player_lower, date_rank)
# 3) Preparar claves en db_complete
db_complete[, w_player_lower := tolower(w_player)]
db_complete[, l_player_lower := tolower(l_player)]
# ⚠️ Eliminar partidos sin fecha
db_complete <- db_complete[!is.na(date_match)]
# 4) Rolling join para columnas del jugador ganador
db_complete[, `:=`(
w_rank     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
w_birthdate= rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
w_weight   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
w_height   = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.height],
w_tpro     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
w_hand     = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
w_backhand = rank[.SD, on = .(player_lower = w_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 5) Rolling join para columnas del jugador perdedor
db_complete[, `:=`(
l_rank     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.rank_position],
l_birthdate= rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.birthdate],
l_weight   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.weight],
l_height   = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.height],
l_tpro     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.turnedpro],
l_hand     = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.hand],
l_backhand = rank[.SD, on = .(player_lower = l_player_lower, date_rank = date_match),
roll = TRUE, x.backhand]
)]
# 6) Limpiar temporales
db_complete[, c("w_player_lower", "l_player_lower") := NULL]
rank[, player_lower := NULL]
# 1) Eliminar columnas temporales (start y end)
db_complete[, c("start", "end") := NULL]
# Primero verificar que existan las columnas necesarias
required_cols <- c("date_match", "w_birthdate", "l_birthdate")
if(all(required_cols %in% colnames(db_complete))){
# Convertir date_match a Date (yyyy-mm-dd)
db_complete$date_match <- as.Date(db_complete$date_match, format = "%Y-%m-%d")
# Asegurarse de que sea carácter antes de convertir
db_complete$w_birthdate <- as.Date(as.character(db_complete$w_birthdate), format = "%Y%m%d")
db_complete$l_birthdate <- as.Date(as.character(db_complete$l_birthdate), format = "%Y%m%d")
db_complete$w_age <- as.numeric(difftime(db_complete$date_match, db_complete$w_birthdate, units = "days")) / 365.25
db_complete$l_age <- as.numeric(difftime(db_complete$date_match, db_complete$l_birthdate, units = "days")) / 365.25
} else {
missing <- required_cols[!(required_cols %in% colnames(db_complete))]
stop(paste("Faltan columnas necesarias:", paste(missing, collapse = ", ")))
}
# 2) Reordenar columnas según el orden deseado
setcolorder(db_complete, c(
"match_id", "tourney_level", "tourney_name", "country", "surface", "round_match", "date_match",
"w_player", "w_nac", "w_age", "w_rank", "w_birthdate", "w_seed", "w_weight", "w_height", "w_tpro", "w_hand", "w_backhand",
"l_player", "l_nac", "l_age", "l_rank", "l_birthdate", "l_seed", "l_weight", "l_height", "l_tpro", "l_hand", "l_backhand",
"timestart", "score", "match_status", "best", "time_total",
"time_1s", "time_2s", "time_3s", "time_4s", "time_5s", "coments", "winner"
))
db <- db_complete
rm(db_complete, rank, players_database, players_subset)
rm(required_cols, ruta_csv, con)
gc()       # libera memoria de forma explícita
# Definimos la ruta base
ruta <- "/Users/paula/Documents/TennisData/TennisData/database/"
# 1. Guardar el CSV
write.csv(db, file.path(ruta, "matches_raw.csv"), row.names = FALSE)
# 2. Comprimirlo en un ZIP
zip(file.path(ruta, "matches_raw.zip"),
files = file.path(ruta, "matches_raw.csv"))
# 3. (opcional) borrar el CSV original si solo querés el ZIP
file.remove(file.path(ruta, "matches_raw.csv"))
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[!round_match %in% c('Q1', 'Q2', 'Q3')]
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
# Ganados por jugador y año
ganados <- dbm[, .N, by = .(year, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[, .N, by = .(year, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
# Calcular porcentajes
resultados[, `% ganados` := round(Ganados * 100 / Jugados, 1)]
resultados[, `% perdidos` := round(Perdidos * 100 / Jugados, 1)]
View(resultados)
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[!round_match %in% c('Q1', 'Q2', 'Q3')]
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
# Ganados por jugador y año
ganados <- dbm[w_nac=='Argentina', .N, by = .(year, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[l_nac=='Argentina', .N, by = .(year, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
# Calcular porcentajes
resultados[, `% ganados` := round(Ganados * 100 / Jugados, 1)]
resultados[, `% perdidos` := round(Perdidos * 100 / Jugados, 1)]
View(resultados)
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[!round_match %in% c('Q1', 'Q2', 'Q3')]
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
colnames(dbm)
library(data.table)
# Asegúrate de que dbm sea un data.table
setDT(dbm)
# Filtrar finales ganadas y contar cuántas ganó cada jugador
final_winners <- dbm[round_match == "F", .N, by = w_player][order(-N)]
# Cambiar el nombre de la columna para mayor claridad
setnames(final_winners, "N", "finals_won")
# Mostrar resultado
final_winners
View(final_winners)
library(data.table)
setDT(dbm)
# 1️⃣ Jugadores que ganaron al menos una final
final_winners <- unique(dbm[round_match == "F", w_player])
# 2️⃣ Contar total de victorias (todos los partidos ganados) para esos jugadores
total_wins <- dbm[w_player %in% final_winners, .N, by = w_player][order(-N)]
# 3️⃣ Renombrar columna para claridad
setnames(total_wins, "N", "total_wins")
# Resultado
total_wins
View(total_wins)
View(dbm)
View(dbm)
library(data.table)
setDT(dbm)
# Asegurar formato de fecha
dbm[, date_match := as.Date(date_match)]
# 1️⃣ Identificar fecha de la primera final ganada por cada jugador
first_titles <- dbm[round_match == "F", .(first_title_date = min(date_match)), by = w_player]
# 2️⃣ Fecha de la primera victoria profesional de cada jugador
first_wins <- dbm[, .(first_win_date = min(date_match)), by = w_player]
# 3️⃣ Unir ambas tablas (solo jugadores que ganaron alguna final)
career_milestones <- merge(first_titles, first_wins, by = "w_player")
# 4️⃣ Contar los partidos ganados desde la primera victoria hasta la fecha del primer título
wins_until_title <- dbm[w_player %in% career_milestones$w_player,
.(total_wins_until_title = sum(date_match <= career_milestones[w_player == .BY$w_player, first_title_date] &
date_match >= career_milestones[w_player == .BY$w_player, first_win_date])),
by = w_player]
# 5️⃣ Ordenar por menor cantidad de victorias necesarias para llegar al primer título
wins_until_title <- wins_until_title[order(total_wins_until_title)]
# Resultado final
wins_until_title
View(wins_until_title)
