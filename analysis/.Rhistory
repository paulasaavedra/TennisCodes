dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[!round_match %in% c('Q1', 'Q2', 'Q3')]
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
# Ganados por jugador y año
ganados <- dbm[w_nac == 'Argentina', .N, by = .(year, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[l_nac == 'Argentina', .N, by = .(year, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
# Calcular porcentajes
resultados[, `% ganados` := round(Ganados * 100 / Jugados, 1)]
resultados[, `% perdidos` := round(Perdidos * 100 / Jugados, 1)]
View(resultados)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
# setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[!round_match %in% c('Q1', 'Q2', 'Q3')]
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
ganados <- dbm [round_match=='R32' & w_nac == 'Argentina' & tourney_level=='M1000']
auxi <- ganados[,.N,by=c('w_player')]
View(auxi)
ganados <- dbm [round_match=='R32' & w_nac == 'Argentina']
auxi <- ganados[,.N,by=c('w_player')]
ganados <- dbm [round_match=='R32' & w_nac == 'Argentina' & tourney_level=='M1000']
auxi <- ganados[,.N,by=c('w_player')]
ganados <- dbm [round_match=='R32' & w_nac == 'Argentina' & tourney_level=='M1000' & year>1989]
auxi <- ganados[,.N,by=c('w_player')]
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
# setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
rondas <- db[,.N,byc('round_match')]
rondas <- db[,.N,by=c('round_match')]
View(rondas)
rondas <- db[,.N,by=c('tourney_level')]
rondas <- db[,.N,by=c('l_nac')]
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
# setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[!round_match %in% c('Q1', 'Q2', 'Q3')]
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
# Ganados por jugador y año
ganados <- dbm[w_nac == 'Argentina', .N, by = .(year, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[l_nac == 'Argentina', .N, by = .(year, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
# Calcular porcentajes
resultados[, `% ganados` := round(Ganados * 100 / Jugados, 1)]
resultados[, `% perdidos` := round(Perdidos * 100 / Jugados, 1)]
View(resultados)
resumen <- resultados[Ganados>30]
View(resumen)
auxi <- resumen[,.N,by=Jugador]
View(auxi)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
# setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(dplyr)
library(tidyr)
library(data.table)
dbm <- db[tourney_level != 'CH']
dbm <- dbm[match_status != 'Walkover']
dbm <- dbm[!round_match %in% c('Q1', 'Q2', 'Q3')]
dbm <- dbm [tourney_level=='M1000']
# Limpia match_id y separa en year + id
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)
dbm[, id := as.character(id)]
dbm[, year := as.integer(year)]
dbm <- dbm[year>1989]
# Ganados por jugador y año
ganados <- dbm[w_nac == 'Argentina', .N, by = .(year, Jugador = w_player)]
# Perdidos por jugador y año
perdidos <- dbm[l_nac == 'Argentina', .N, by = .(year, Jugador = l_player)]
# Renombrar columnas
setnames(ganados, "N", "Ganados")
setnames(perdidos, "N", "Perdidos")
# Unir resultados por jugador y año
resultados <- merge(ganados, perdidos, by = c("year", "Jugador"), all = TRUE)
# Reemplazar NAs con 0
resultados[is.na(resultados)] <- 0
# Calcular jugados
resultados[, Jugados := Ganados + Perdidos]
# Calcular porcentajes
resultados[, `% ganados` := round(Ganados * 100 / Jugados, 1)]
resultados[, `% perdidos` := round(Perdidos * 100 / Jugados, 1)]
View(resultados)
resumen <- resultados[Ganados>14]
View(resumen)
View(resultados)
View(resumen)
resumen <- resultados[Ganados>15]
View(resumen)
View(resultados)
library(dplyr)
library(tidyr)
library(kableExtra)
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status != 'Walkover']
#dbm <- dbm [surface =='Clay']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm <- dbm [tourney_level=='M1000']
#Filtra una fecha
#dbm <- dbm [as.Date(date_match, format = "%Y-%m-%d") > as.Date("2024-12-20")]
# Filtra enero o febrero
#dbm <- dbm[month(as.Date(date_match, format = "%Y-%m-%d")) %in% c(1, 2, 3)]
#dbm <- dbm[grepl("RIO DE J", tourney_name, ignore.case = TRUE)]
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
dbm <- dbm [year>='2025']
#dbm <- dbm [tourney_level=='M1000']
# Filtrar por id
#dbm <- dbm[id %in% c( "0308")]
ganados <- dbm[w_nac == 'Argentina']
perdidos <- dbm[l_nac=='Argentina']
ganados <- ganados[,.N, by = w_player]
perdidos <- perdidos[,.N, by = l_player]
# Nombrar columnas con "Jugador" y "Ganados" "Perdidos"
names(ganados)[1] <- names(perdidos)[1] <- "Jugador"
names(ganados)[2] <- "Ganados"
names(perdidos)[2] <- "Perdidos"
# Unir resultados por nombre
resultados <- merge(ganados, perdidos, by = c("Jugador"), all=TRUE)
# Poner 0 a los que tienen NA
resultados[is.na(resultados)] <- 0
# sumar ganados y perdidos en una misma columna llamada "Jugados"
resultados <- resultados[, Jugados:=Ganados+Perdidos]
#resultados <- resultados[Jugados>4]
resultados <- resultados[, PorGan:= round(resultados$Ganados*100/resultados$Jugados, 1)]
resultados <- resultados[, PorPer:= round(resultados$Perdidos*100/resultados$Jugados, 1)]
names(resultados)[5] <- "% ganados"
names(resultados)[6] <- "% perdidos"
View(resultados)
library(dplyr)
library(tidyr)
library(kableExtra)
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status != 'Walkover']
#dbm <- dbm [surface =='Clay']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm <- dbm [tourney_level=='M1000']
#Filtra una fecha
#dbm <- dbm [as.Date(date_match, format = "%Y-%m-%d") > as.Date("2024-12-20")]
# Filtra enero o febrero
#dbm <- dbm[month(as.Date(date_match, format = "%Y-%m-%d")) %in% c(1, 2, 3)]
#dbm <- dbm[grepl("RIO DE J", tourney_name, ignore.case = TRUE)]
dbm[, match_id := sub("_\\d+$", "", match_id)]
dbm <- dbm %>%
separate(match_id, into = c("year", "id"), sep = "_")
setDT(dbm)  # Convierte dbm en data.table si dejó de serlo
dbm[, id := as.character(id)]
dbm <- dbm [year>='1990']
#dbm <- dbm [tourney_level=='M1000']
# Filtrar por id
#dbm <- dbm[id %in% c( "0308")]
ganados <- dbm[w_nac == 'Argentina']
perdidos <- dbm[l_nac=='Argentina']
ganados <- ganados[,.N, by = w_player]
perdidos <- perdidos[,.N, by = l_player]
# Nombrar columnas con "Jugador" y "Ganados" "Perdidos"
names(ganados)[1] <- names(perdidos)[1] <- "Jugador"
names(ganados)[2] <- "Ganados"
names(perdidos)[2] <- "Perdidos"
# Unir resultados por nombre
resultados <- merge(ganados, perdidos, by = c("Jugador"), all=TRUE)
# Poner 0 a los que tienen NA
resultados[is.na(resultados)] <- 0
# sumar ganados y perdidos en una misma columna llamada "Jugados"
resultados <- resultados[, Jugados:=Ganados+Perdidos]
#resultados <- resultados[Jugados>4]
resultados <- resultados[, PorGan:= round(resultados$Ganados*100/resultados$Jugados, 1)]
resultados <- resultados[, PorPer:= round(resultados$Perdidos*100/resultados$Jugados, 1)]
names(resultados)[5] <- "% ganados"
names(resultados)[6] <- "% perdidos"
View(resultados)
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
# setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
# setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(dplyr)
library(tidyr)
library(kableExtra)
library(ggplot2)
# Filtro que no este el nivel CH, que los partidos esten terminados y que no haya ronda de clasificación.
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status == 'Finished']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm <- dbm [tourney_name != 'Davis Cup']
# Filtro la fecha para tener solo partidos de 2025
dbm <- dbm [as.Date(date_match, format = "%Y-%m-%d") > as.Date("2024-12-20")]
dbm_pbyp <- pbyp[match_id %in% dbm$match_id]
source("~/Documents/TennisData/TennisCodes/analysis/Leer_db.R")
# Cargar librerías
library(DBI)
library(RMariaDB)
library(data.table)
# Establecer la conexión
con <- dbConnect(
MariaDB(),
dbname = "tennis_db",
host = "localhost",
user = "root",
password = "tennis46"
)
# Listar tablas disponibles
dbListTables(con)
# Leo atp_simple
setnames(db <- setDT(dbReadTable(con, "atp_simple")), tolower(names(db)))
setnames(pbyp <- setDT(dbReadTable(con, "atp_pbyp")), tolower(names(pbyp)))
# setnames(rank <- setDT(dbReadTable(con, "atp_rankings")), tolower(names(rank)))
# setnames(db_stats_w_t <- setDT(dbReadTable(con, "atp_stats_w_t")), tolower(names(db_stats_w_t)))
# setnames(db_stats_l_t <- setDT(dbReadTable(con, "atp_stats_l_t")), tolower(names(db_stats_l_t)))
# Cerrar la conexión
dbDisconnect(con)
library(dplyr)
library(tidyr)
library(kableExtra)
library(ggplot2)
# Filtro que no este el nivel CH, que los partidos esten terminados y que no haya ronda de clasificación.
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status == 'Finished']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm <- dbm [tourney_name != 'Davis Cup']
# Filtro la fecha para tener solo partidos de 2025
dbm <- dbm [as.Date(date_match, format = "%Y-%m-%d") > as.Date("2024-12-20")]
dbm_pbyp <- pbyp[match_id %in% dbm$match_id]
dbm_pbyp <- merge(dbm, dbm_pbyp, by = c("match_id"), all=TRUE)
View(dbm_pbyp)
dbm_pbyp$serve_game
library(dplyr)
library(tidyr)
library(kableExtra)
library(ggplot2)
# Filtro que no este el nivel CH, que los partidos esten terminados y que no haya ronda de clasificación.
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status == 'Finished']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm <- dbm [tourney_name != 'Davis Cup']
# Filtro la fecha para tener solo partidos de 2025
dbm <- dbm [as.Date(date_match, format = "%Y-%m-%d") > as.Date("2024-12-20")]
dbm_pbyp <- pbyp[match_id %in% dbm$match_id]
dbm_pbyp <- merge(dbm, dbm_pbyp, by = c("match_id"), all=TRUE)
dbm_pbyp <- dbm_pbyp[serve_game=='Alexander Zverev' & return_game=='Francisco Cerundolo']
setorder(dbm_pbyp, match_id,point_number)
aux <- dbm_pbyp %>%
separate(game_score, into = c("p1", "p2"), sep = ":", fill = "right", remove = FALSE)
setDT(aux)
aux[p1 == "A", p1 := "50"]
aux[p2 == "A", p2 := "50"]
# Suponiendo que pbyp_tomi ya es un data.table y está ordenado en orden cronológico
aux[, point_winner := ifelse(
(shift(p1, type = "lag") < p1) |  # Regla 1: P1 gana si su valor actual es mayor que el anterior
((p1 == 0 & shift(p1, type = "lag") == 40) & shift(p2, type = "lag") != 50) |  # Regla 2
(p1 == 0 & shift(p1, type = "lag") == 50) |  # Regla 3
((shift(p1, type = "lag") == 40 & p1 == 40) & (shift(p2, type = "lag") == 50 & p2 == 40)),  # Regla 4
"P1", "P2"  # Si no se cumple ninguna condición, P2 gana el punto
)]
aux[, point_winner := ifelse(is.na(point_winner), "Nada", point_winner)]
aux[, score := cumsum(ifelse(point_winner == "P1", 1, -1))]
# Reemplazar "P1" por el valor de return_game
aux[point_winner == "P1", point_winner := return_game]
# Reemplazar "P2" por el valor de serve_game
aux[point_winner == "P2", point_winner := serve_game]
# Identificar los bloques consecutivos donde match_score se mantiene igual
aux[, grupo := rleid(match_score)]
# Quedarte con la última fila de cada grupo
ultimo_punto <- aux[, .SD[.N], by = grupo]
# Si ya no quieres la columna 'grupo', la puedes eliminar
ultimo_punto[, grupo := NULL]
# Crear la columna break
ultimo_punto[, g_break := ifelse(point_winner != serve_game, "break", NA_character_)]
# Crear un identificador de grupo que cambia cada vez que match_score CONTIENE "0-0"
ultimo_punto[, game_group := cumsum(grepl("0-0", match_score))]
# Crear la columna incremental que se reinicia por grupo
ultimo_punto[, game_number := seq_len(.N), by = game_group]
# Filtrar solo las filas que son break y contar por game_number
conteo_breaks <- ultimo_punto[g_break == "break", .N, by = game_number]
# Eliminar la última fila
conteo_breaks <- conteo_breaks[-.N]
# Ordenar para ver cuál game_number tuvo más breaks
conteo_breaks <- conteo_breaks[order(-N)]
# Calcular un límite superior un poco mayor al máximo valor
x_lim_max <- max(conteo_breaks$N) * 1.1  # Aumenta en 10%
# Barplot con límite de eje X expandido
bp <- barplot(conteo_breaks$N, names.arg = conteo_breaks$game_number,
horiz = TRUE,
las = 1,
col = "skyblue",
xlab = "Cantidad de Quiebres",
ylab = "Game Number",
main = "Cantidad de Quiebres por Game",
xlim = c(0, x_lim_max))  # Aumentamos el eje X
# Añadir etiquetas
text(x = conteo_breaks$N,
y = bp,
labels = conteo_breaks$N,
pos = 4,
cex = 0.8,
col = "black")
View(db)
library(dplyr)
library(tidyr)
library(kableExtra)
library(ggplot2)
# Filtro que no este el nivel CH, que los partidos esten terminados y que no haya ronda de clasificación.
dbm <- db [tourney_level != 'CH']
dbm <- dbm [match_status == 'Finished']
dbm <- dbm [round_match != 'Q1' & round_match != 'Q2' & round_match != 'Q3']
dbm <- dbm [tourney_name != 'Davis Cup']
# Filtro la fecha para tener solo partidos de 2025
dbm <- dbm [as.Date(date_match, format = "%Y-%m-%d") > as.Date("2024-12-20")]
dbm_pbyp <- pbyp[match_id %in% dbm$match_id]
dbm_pbyp <- merge(dbm, dbm_pbyp, by = c("match_id"), all=TRUE)
dbm_pbyp <- dbm_pbyp[serve_game=='Alexander Zverev' & return_game!='Francisco Cerundolo']
setorder(dbm_pbyp, match_id,point_number)
aux <- dbm_pbyp %>%
separate(game_score, into = c("p1", "p2"), sep = ":", fill = "right", remove = FALSE)
setDT(aux)
aux[p1 == "A", p1 := "50"]
aux[p2 == "A", p2 := "50"]
# Suponiendo que pbyp_tomi ya es un data.table y está ordenado en orden cronológico
aux[, point_winner := ifelse(
(shift(p1, type = "lag") < p1) |  # Regla 1: P1 gana si su valor actual es mayor que el anterior
((p1 == 0 & shift(p1, type = "lag") == 40) & shift(p2, type = "lag") != 50) |  # Regla 2
(p1 == 0 & shift(p1, type = "lag") == 50) |  # Regla 3
((shift(p1, type = "lag") == 40 & p1 == 40) & (shift(p2, type = "lag") == 50 & p2 == 40)),  # Regla 4
"P1", "P2"  # Si no se cumple ninguna condición, P2 gana el punto
)]
aux[, point_winner := ifelse(is.na(point_winner), "Nada", point_winner)]
aux[, score := cumsum(ifelse(point_winner == "P1", 1, -1))]
# Reemplazar "P1" por el valor de return_game
aux[point_winner == "P1", point_winner := return_game]
# Reemplazar "P2" por el valor de serve_game
aux[point_winner == "P2", point_winner := serve_game]
# Identificar los bloques consecutivos donde match_score se mantiene igual
aux[, grupo := rleid(match_score)]
# Quedarte con la última fila de cada grupo
ultimo_punto <- aux[, .SD[.N], by = grupo]
# Si ya no quieres la columna 'grupo', la puedes eliminar
ultimo_punto[, grupo := NULL]
# Crear la columna break
ultimo_punto[, g_break := ifelse(point_winner != serve_game, "break", NA_character_)]
# Crear un identificador de grupo que cambia cada vez que match_score CONTIENE "0-0"
ultimo_punto[, game_group := cumsum(grepl("0-0", match_score))]
# Crear la columna incremental que se reinicia por grupo
ultimo_punto[, game_number := seq_len(.N), by = game_group]
# Filtrar solo las filas que son break y contar por game_number
conteo_breaks <- ultimo_punto[g_break == "break", .N, by = game_number]
# Eliminar la última fila
conteo_breaks <- conteo_breaks[-.N]
# Ordenar para ver cuál game_number tuvo más breaks
conteo_breaks <- conteo_breaks[order(-N)]
# Calcular un límite superior un poco mayor al máximo valor
x_lim_max <- max(conteo_breaks$N) * 1.1  # Aumenta en 10%
# Barplot con límite de eje X expandido
bp <- barplot(conteo_breaks$N, names.arg = conteo_breaks$game_number,
horiz = TRUE,
las = 1,
col = "skyblue",
xlab = "Cantidad de Quiebres",
ylab = "Game Number",
main = "Cantidad de Quiebres por Game",
xlim = c(0, x_lim_max))  # Aumentamos el eje X
# Añadir etiquetas
text(x = conteo_breaks$N,
y = bp,
labels = conteo_breaks$N,
pos = 4,
cex = 0.8,
col = "black")
